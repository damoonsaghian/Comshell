Rust makes bad programming hard, and good programming fun;
Rust does not hide (inherent) complexity, in fact it bolds it, so we can see it, and avoid it;
by inherent complexity i mean a complexity which can not be abstracted away completely;
  ie if we try to hide it, it will re_emerge somewhere else;
in fact, hiding inherent complexity usually leads to choosing the wrong approach;

sharing mutable data,
  ie having a mutable reference to some data, while it is shared using other references,
  is the root of many (inherent) complexities;
"https://manishearth.github.io/blog/2015/05/17/the-problem-with-shared-mutability/"

static data (functions, structs, constants): no problem, copy or share by reference;
dynamic data: can have fixed structure, or dynamic structure;
, if data has a fixed structure we usually put it on stack;
  so we don't share it across the program, we copy it;
  if the data is big and we want to share it, we can put it inside a cell on the heap,
    and share references to it across the program, using &;
  since the structure of data is fixed we can mutate it from anywhere (in the same tread);
, but in general where the structure of data is not fixed,
  we need to check if the read_write_lock pattern is fulfilled,
  either statically (when sharing refs using &mut),
  or dynamically at runtime, by putting it inside a RefCell
    (or its multi_threaded counterparts: Mutex or RwLock);
  note that if runtime read_write_lock pattern fails, the program will panic;

actors can help us to avoid the need for read_write_lock check (during compilation or at runtime);
"https://crates.io/crates/may_actor"

a type is "Copy" if all the data it owns is part of its stack representation;
  in other words if a copy of its stack representation doesn't violate memory safety;
"&T" and raw pointers are "Copy", "&mut T" isn't "Copy" (it's "Move");

in Rust any resource have exactly one owner which takes care of its resource deallocation;
owners can share their data by lending them to references;
references must have a lifetime less than the owner;
furthermore lifetime of a mutable reference must not overlap with other references;
"http://blog.skylight.io/rust-means-never-having-to-close-a-socket/"

owner can:
, access and mutate resource;
, lend the resource to a reference;
, hand over ownership (move), or deallocate resource;
but during a lend, owner can't:
, mutate the resource;
, mutably lend resouce to another reference;
, hand over ownership (move), or deallocate resource;
and during a mutable lend, owner can't even access the resource;

references (shared references) can:
, access borrowed resource;
, immutably lend resource to other references;
mutable reference (exclusive reference) can:
, access and mutate resource;
, mutably lend resource to another reference;
  they can immutably lend resource, but then they can mutate it;
  just like when an owner immutably lends its resource;

during shared borrow (immutable borrow) no one owns the data;
  so even the original owner can't change it;
during mutable borrow the (unique) borrower owns it;
so "&mut" is actually a temporary transfer of ownership;

scenarios that involve returning refs often require explicit lifetimes;
  so don't return refs, instead use mutable refs in inputs;

s: String -> &s: &String -> &s[..]: &str
v: Vec<T> -> &v: &Vec<T> -> &v[..]: &[T]
&str and &[T] are slices; str and [T] are unsized types;
slicing is like borrowing from an unsized type;
since the the slice contains the size, the lending type itself doesn't need to have a definite size;

x = a[i] -> this is possible if the elements of "a" are copy
  (cause moving out of collections is not possible);
x = &a[i] -> this is for the case when the elements are not copy;
x = a[i..j] -> this is always invalid;
x = &a[i..j] -> slicing;

auto ref/deref for self in method calls:
  insert as many * or & as necessary to get it right;
because in method calls name and context of a method call is almost always sufficient
  to infer the move/borrow semantics;

deref coercion:
, &T -> &U when T: Deref<Target=U>
, &mut T -> &U when T: Deref<Target=U>
, &mut T -> &mut U when T: DerefMut<Target=U>
examples:
  &&i32 -> &i32 because &i32: Deref<Target=i32>
  &String -> &str because String: Deref<Target=str>
  &Vec<T> -> &[T] because Vec<T>: Deref<Target=[T]>
"https://github.com/rust-lang/rfcs/blob/master/text/0241-deref-conversions.md"

= type system
types show us what we can do with the data, ie which operations are valid;

the class hierarchy design, eg in Java, is problematic;
  "http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html"
also the problem of covariance for generic types, has its root in this problem;
  "https://en.wikipedia.org/wiki/Wildcard_(Java)"
i think this problem is also the motivation for dynamic typing (another bad design);
the right way as done in Rust:
, concrete types (like final classes in Java) can be instantiated, but cannot have subtypes;
, abstract types (like abstract classes in Java) cannot be instantiated, but can have subtypes;

note that "x.m()" is method call syntax, which completely differs from "(x.m)()";

in "use" statements:
, crate_name::...
, self::local_item::...
even outside "use" statements, we can build absolute paths using crate names at the beginning;
  but since it can conflict with a local name, it's better to avoid it, and instead,
  either insert a "::" at the beginning, before the crate's name,
  or bring the crate's name into scope using a "use" statement;

arrays like tuples have fixed size and thus stored on stack;
  but since they are homogeneous (all elements are of the same type), they can be indexed at runtime;
vectors and hash tables are homogeneous, varying sized collections;

Rust does not have named arguments and named tuples; and it's a good thing;
when you need functions with lots of arguments, or tuples with lots of elements,
  it's a sign that you need to restructure your code, and use structs to define new types;

a closure is like an anonymous struct made of variables captured from environment,
  that is callable (implements Fn/FnMut/FnOnce trait);
so all closures are unique types, but they have traits in common;
note that if we put a generic type parameter in the return type of a function,
  we have to provide the concrete type when we call the function;
  thus we can't use generic type parameters to return a closure, we have to use "impl";

"fn(T1) -> T2" is not an unsized type like "str", it's a function pointer;

= learning
actors can contain parameters which can be adjusted gradually, based on received messages;
  this can be used to implement learning capabilities;
