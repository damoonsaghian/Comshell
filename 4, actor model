the problem with concurrency is sharing mutable data;
ie having a mutable reference to some data, while it is shared using other references;
to prevent sharing mutable data, we can:
, abandon mutability like in Haskell; but since mutability is necessary in some cases,
  a complicated mechanism (Monads) must be created;
, abandon aliasing like in Rust, and copy, move, or borrow instead;
  actually this also allows Rust to eliminate the need for garbage collection;
  but since aliasing is needed in some cases (asynchronous calls),
    we have to reintroduce aliasing (and garbage collection) again;
  so we end up with more complexities, without achieving anything;

another approach to deal with mutable data shared concurrently, is the one used in Pony;
"https://www.ponylang.io/"
it doesn't abandon aliasing nor mutability;
instead it controls them using reference capabilities;

                  |        RW         |          R        |        ...        |
-------------------------------------------------------------------------------
local alias: ...  |        iso        |         ...       |        ...        |
-------------------------------------------------------------------------------
local alias: R    |        trn        |         val       |        ...        |
-------------------------------------------------------------------------------
local alias: RW   |        ref        |         box       |        tag        |
-------------------------------------------------------------------------------
                  | global alias: ... |  global alias: R  | global alias: RW  |

the first column allows mutability, cause other actors can't write;
the second column needs immutability, cause other actors can read;
the last column is opaque (no read/write is allowed), cause other actors can read or write;

Pony's approach introduces many complexities, especially when dealing with generics;
in fact we only need two kind of data:
, immutable data which we can have direct access to it;
, actors which are mutable but we don't have direct access to it;
  any access must go through the actor's process itself;

Actim programming language
two backends:
, compiled to Python: this inevitably will be single threaded,
  but instead we have access to all available API in Python world;
, compiled to Pony: its obviously easier than dealing directly LLVM;
  cause everything (actors, garbage collection ...) is already implemented;
  and frankly Pony is the only sane language i could find on top of LLVM;

= type system
types show us what we can do with the data, ie which operations are valid;
the class hierarchy design, like the one in Java, is problematic;
  "http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html"
also the problem of covariance for generic types, has its root in this problem;
  "https://en.wikipedia.org/wiki/Wildcard_(Java)"
i think this problem is also the motivation for dynamic typing (another bad design);
the right way as done in Rust and Pony:
, concrete types (like final classes in Java) can be instantiated, but cannot have subtypes;
, abstract types (like abstract classes in Java) cannot be instantiated, but can have subtypes;

programs are made of three kind of blocks:
, start: where program starts;
, struct: which can make immutable data;
, class: which can make actors;
class Class'name
  a: T
  fn init() =>
    x: T = 1
    self.a = 1

note that there is no variable assignment; assignment is only possible in a method like this:
  self.field'name = value
closure: fn (a: T1, b: T2): T3 => a + b end
tuple: (1, 2)
named tuple: (a = 1, b = 2)
array: [1, 2]
hash table: ["a" => 1, "b" => 2]

actors can contain parameters which can be adjusted gradually, based on received messages;
  this can be used to implement learning capabilities;
