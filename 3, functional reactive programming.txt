imperative programming is done by procedurally changing stored values,
  it resembles the way CPU runs the instructions stored in memory;
imperative programming leads to unmaintainable code in large programs
  (even if we hide the mentioned complexities behind a garbage collector),
  and it makes writing parallel programs a cumbersome task;

functional reactive programming:
when the output channels of a function is empty and the input channels are full,
  the function consumes its inputs and fills its outputs with computed values;
initially all channels have default values, so feedbacks are possible;

, static data (functions, structs, constants): no problem, share by reference;
, dynamic data:
  , small data: copy (share by copying);
  , big data: move (no sharing);
functional reactive programming allows us to program without the need to share big data;
, just keep related states in one place;
, a set of messages can be received at inputs;
, each kind of message changes one part of the state;

functions which only move/copy (ie do not borrow) their input/output, are called gates;
async programming with gates are much simpler,
  without the need for shared mutability (RefCell) and shared ownership (RC),
  which need runtime solutions;

gates can be made purely of other gates;
but using non_gate functions (functions with & in their signature)
  to implement the internal of a gate is sometimes better,
  in order to prevent cloning big data;

from "Henry G Baker, use_once variables and linear objects":
use_once variables are bound to linear (unshared, unaliased, or singly_referenced) objects;
linear objects are cheap to access and manage,
  because they require no synchronization or tracing garbage collection;
linear objects can elegantly and efficiently solve
  otherwise difficult problems of functional systems,
  eg in_place updating and the efficient initialization of functional objects;
linear objects and use_once variables map elegantly
  into data_flow models of concurrent computation;
  and the graphical representations of data_flow models
    make an appealing visual linear programming language;

streams in "future" crate:
, i don't like its API:
  a bunch of different types implementing the stream trait;
, can't see a way to easily create feedbacks;
"carboxyl" crate:
, two separate concepts: streams (which are push based), signals (which are pull based);
, seems abondoned;
, 'static in the type of values of a stream !?
"bidule" crate:
, the implementation seems sequential (not async);
, lifetimes for the values of a stream !?

async computations:
"https://docs.rs/threadpool"
"https://docs.rs/jobpool"
"https://crates.io/crates/threads_pool" (depends on crossbeam)
"https://docs.rs/rayon-core/*/rayon_core/struct.ThreadPool.html" (depends on crossbeam)

channels for syncing:
"https://docs.rs/bus"
"https://docs.rs/spmc"

let pool = ThreadPool::new(num_cpus::get_physical());

let mut stream1 = Bus.new(0);
let mut stream1_rx1 = stream1.add_rx();
let mut stream1_rx2 = stream1.add_rx();
// set initial value to make feedbacks possible;
stream1.try_broadcast(initial_value);

let mut stream2 = Bus.new(0);
let mut stream2_rx = stream2.add_rx();
stream2.try_broadcast(initial_value);
pool.execute(move || {
  loop {
    stream2.broadcast(
      function(stream1_rx1.recv().unwrap())
    );
  }
};
