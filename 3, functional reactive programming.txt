imperative programming is done by procedurally changing stored values,
  it resembles the way CPU runs the instructions stored in memory;
imperative programming leads to unmaintainable code in large programs
  (even if we hide the mentioned complexities behind a garbage collector),
  and it makes writing parallel programs a cumbersome task;

functional reactive programming:
when the output channels of a function is empty and the input channels are full,
  the function consumes its inputs and fills its outputs with computed values;
initially all channels have default values, so feedbacks are possible;

, static data (functions, structs, constants): no problem, share by reference;
, dynamic data:
  , small data: copy (share by copying);
  , big data: move (no sharing);
functional reactive programming allows us to program without the need to share big data;
, just keep related states in one place;
, a set of messages can be received at inputs;
, each kind of message changes one part of the state;

from "Henry G Baker, use_once variables and linear objects":
use_once variables are bound to linear (unshared, unaliased, or singly_referenced) objects;
linear objects are cheap to access and manage,
  because they require no synchronization or tracing garbage collection;
linear objects can elegantly and efficiently solve
  otherwise difficult problems of functional systems,
  eg in_place updating and the efficient initialization of functional objects;
linear objects and use_once variables map elegantly
  into data_flow models of concurrent computation;
  and the graphical representations of data_flow models
    make an appealing visual linear programming language;

streams in future crate:
, the designed types are not suitable for stream combination;
, currently there is no way (that i know) to branch streams;
  pinned trait solves this;

async computations:
"https://docs.rs/threadpool"
"https://docs.rs/jobpool"
"https://crates.io/crates/threads_pool"
"https://docs.rs/rayon-core/*/rayon_core/struct.ThreadPool.html"

channels for syncing:
"https://docs.rs/bus"
"https://docs.rs/spmc"

let pool = ThreadPool::new(num_cpus::get_physical());

let mut stream1 = Bus.new(0);
let mut stream1_rx1 = stream1.add_rx();
let mut stream1_rx2 = stream1.add_rx();
// set initial value to make feedbacks possible;
stream1.try_broadcast(initial_value);

let mut stream2 = Bus.new(0);
let mut stream2_rx = stream2.add_rx();
stream2.try_broadcast(initial_value);
pool.execute(move || {
  loop {
    stream2.broadcast(
      function(stream1_rx1.recv().unwrap())
    );
  }
};
