= asynchronous digital circuits
in conventional digital circuits when the inputs change,
  the outputs can have temporary invalid values, until they stabilize to the valid values;
but for the circuit to do its job,
  gates with memory (registers) must operate only when the inputs have correct values;
one solution is to synchronize registers with a global clock signal;
  the period of clock signal is made long enough for the circuit to become stable;

disadvantages of synchronous circuits:
, we have to split long operations into several smaller ones,
  which can be performed in successive clock cycles (a technique known as pipelining);
  otherwise the circuit would be slow and inefficient;
, distributing a high-fan-out, timing-sensitive clock signal can be complicated;
, electromagnetic interference at the clock frequency and its harmonics;
, widely distributed clock signal takes a lot of power,
  and must run whether the circuit is receiving inputs or not;
although "clock gating" can help to reduce some of the problems of synchronous circuits,
 i think the real solution is to use asynchronous circuits;

the only sane kind of asynchronous circuit which i could imagine is this:
, next to any data wire there is a control wire which determines if the data is valid or not;
, when a register wants to change its outputs, it first invalidates them,
  for a duration equal to the delay of one gate;
, any gate receiving an invalid input, invalidates its outputs;
, this way all data which is going to change in the future, is first invalidated;
, registers operate only when all inputs are valid;

= computers
cpu, memory, peripherals,
  this seems to be the only practical architecture for the hardware of computers;
cpu runs a sequence of simple computations, called instruction codes, one by one;

compilers are special programs that generate instruction codes,
  from a program written in a structured and human readable language;
Rust is a programming language which provides zero cost abstractions,
  and memory safety without garbage collection;
  thus there is absolutely no reason to write new software in C/C++;

programs usually do not run directly on computer hardware;
instead they run on a more sophisticated software machine (a virtual machine) called the kernel;
in theory we can live without a kernel (an idea sometimes called a library operating system);
but in that case, we have to rewrite all the required libraries, on bare metal;
anyway, having an operating system, makes developing and testing new programs much easier;

Linux is a highly developed, constantly evolving, open_source kernel;
"https://dominuscarnufex.github.io/cours/rs-kernel/en.html"
in Linux (and other Unix based operating systems) most things appear in the file system;
  i think the reason is to make it possible to do lots of things using shell scripts,
    instead of a proper programming language;
  while i can understand the convenience it provides, i don't think it's good design;

= Arch Linux
Arch Linux help us to setup and maintain a Linux system; it's simple and effective;

first boot to an existing Arch Linux (the live image,
  or an already installed Arch Linux with arch-install-scripts package installed);
; timedatectl set-ntp true

list disks using "fdisk -l"; then use "fdisk /dev/sdx" to create 3 partitions:
  , +1M BIOS boot (partition type code: 4)
  , +550M EFI System (partition tye code: 1)
  , and the rest for Linux filesystem
  (first enter "g" command to create a GPT partition table,
    then enter "n" to add a new partition, and change its type using "t" command;
    at the end enter "w" to write and exit;)
format the partitions:
  ; mkfs.fat -F32 /dev/sdx2; mkfs.ext4 /dev/sdx3

; mount /dev/sdx3 /mnt
now you can even reuse packages previously downloaded on current system,
  by copying them to "/mnt/var/cache/pacman/pkg";
; pacstrap /mnt pacman
; arch-chroot /mnt
; pacman -S grub sed intel-ucode linux systemd-sysvcompat logrotate \
  networkmanager pulseaudio-alsa udisks2 sudo nano man-db unzip ttf-hack ttf-droid rustup gcc

install boot_loader:
; grub-install --target=i386-pc /dev/sdx
; mkdir /boot/efi; mount /dev/sdx2 /boot/efi
; grub-install --target=x86_64-efi --efi-directory=/boot/efi --removable
; grub-mkconfig -o /boot/grub/grub.cfg
; nano /boot/grub/grub.cfg
  set timeout = 0

create user:
; useradd -m -G wheel user1
; passwd -d user1
; EDITOR=nano visudo
  %wheel ALL=(ALL) ALL
actually, "sudo" without password has no security advantage over just logging in as root;
nonetheless a regular user is necessary, because
  some programs (like PulseAudio) wouldn't work normally when run as root;

automatic login:
; mkdir /etc/systemd/system/getty@tty1.service.d
; nano /etc/systemd/system/getty@tty1.service.d/override.conf
  [Service]
  ExecStart=
  ExecStart=-/usr/bin/agetty --autologin user1 --noclear %I $TERM

in "/etc/locale.gen" uncomment "en_US.UTF-8 UTF-8";
; locale-gen
; nano /etc/locale.conf
  LANG=en_US.UTF-8

; systemctl enable NetworkManager.service
; systemctl enable systemd-timesyncd.service
; exit
; reboot

some audio devices can send and_or receive volume control signals;
  PulseAudio mutes and silences these device, by default;
so if you like you can do this:
; pactl set-sink-mute @DEFAULT_SINK@ 0
; pactl set-sink-volume @DEFAULT_SINK@ 100%

monitor block events and mount drives when a new block device is created;
  stale mount points are automatically removed by "udisksd";
; nano ~/.bash_profile
  pathtoname() {
    udevadm info -p /sys/"$1" | awk -v FS== '/DEVNAME/ {print $2}'
  }
  stdbuf -oL -- udevadm monitor --udev -s block | while read -r -- _ _ event devpath _; do
    if [ "$event" = add ]; then
      devname=$(pathtoname "$devpath")
      udisksctl mount --block-device "$devname" --no-user-interaction
    fi
  done&

; mkdir -p ~/.config/fontconfig
; nano ~/.config/fontconfig/fonts.conf
  <?xml version='1.0'?>
  <!DOCTYPE fontconfig SYSTEM 'fonts.dtd'>
  <fontconfig>
    <!-- Set preferred serif, sans serif, and monospace fonts; -->
    <alias>
      <family>serif</family>
      <prefer><family>Hack</family></prefer>
    </alias>
    <alias>
      <family>sans-serif</family>
      <prefer><family>Hack</family></prefer>
    </alias>
    <alias>
      <family>sans</family>
      <prefer><family>Hack</family></prefer>
    </alias>
    <alias>
      <family>monospace</family>
      <prefer><family>Hack</family></prefer>
    </alias>
  </fontconfig>

; nano ~/.bash_profile
  export TZ="/usr/share/zoneinfo/<your_location>"

; rustup install stable
; rustup default stable
