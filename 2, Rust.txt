Rust makes bad programming hard, and good programming fun;
Rust does not hide complexity, in fact it bolds it, so we can see it, and avoid it;

managing references in an imperative program is a complex task;
Rust does not hide these complexities behind a garbage collector;
instead it presents them clearly, as is shown in the following;

in Rust any resource have exactly one owner which takes care of its resource deallocation;
"http://blog.skylight.io/rust-means-never-having-to-close-a-socket/"
owners can share their data by lending them to references;
references must have a lifetime less than the owner;
furthermore lifetime of a mutable reference must not overlap with other references;

owner can:
, control resource deallocation;
, lend the resource to a reference;
, hand over ownership (move);
owner can't:
, mutate the resource, during borrow;
, access the resource, during mutable borrow;

references can:
, access borrowed resource;
, immutably lend resource to other references;
mutable reference can:
, access and mutate resource;
, mutably lend resouce to aother reference;

scenarios that involve returning refs often require explicit lifetimes;
  so don't return refs, instead use mutable refs in inputs;
structs and enums containing refs must have explicit lifetimes;
  so don't use them;

Rust have separate types for static and dynamic values; (str/String, fn/Fn)
static data can be defined using only other static data;
functions can only access static environment;
  closures don't have this limitation; so when using them we must be more careful;

Rust has automatic dereferencing in function and method calls
  (because the type signature for functions are mandatory);
although we have to deref explicitly when using overloaded operators
in addition Rust has automatic referencing for self in  method calls;

= type system
types show us what we can do with the data (which operations are valid);

the class hierarchy design like in Java is problematic;
  "http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html"
also the problem of covariance for generic types, has its root in this problem;
  "https://en.wikipedia.org/wiki/Wildcard_(Java)"
i think this is also the motivation for dynamic typing (another bad design);
the right way as done in Rust, Go and Julia:
, concrete types (like final classes in Java) can be instantiated, but cannot have subtypes;
, abstract types (like abstract classes in Java) cannot be instantiated, but can have subtypes;

dot notation is used where we can destucture (tuples, structures);
double colon "::" is for namespacing;

arrays in Rust are homogeneous, fixed sized collection;
since all elements have the same type (unlike tuples), indexing can be done at runtime;
vectors and hash tables are homogeneous, varying sized collection;
