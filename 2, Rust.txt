Rust makes bad programming hard, and good programming fun;
Rust does not hide complexity, in fact it bolds it, so we can see it, and avoid it;

managing references in an imperative program is a complex task;
Rust does not hide these complexities behind a garbage collector;
instead it presents them clearly, as is shown in the following;

in Rust any resource have exactly one owner which takes care of its resource deallocation;
"http://blog.skylight.io/rust-means-never-having-to-close-a-socket/"
owners can share their data by lending them to references;
references must have a lifetime less than the owner;
furthermore lifetime of a mutable reference must not overlap with other references;

owner can:
, access and mutate resource;
, lend the resource to a reference;
, hand over ownership (move);
, control resource deallocation;
owner can't:
, mutate the resource, during borrow;
, access the resource, during mutable borrow;

references (shared references) can:
, access borrowed resource;
, immutably lend resource to other references;
mutable reference (exclusive reference) can:
, access and mutate resource;
, mutably lend resouce to aother reference;

actually borrowing is only needed in imperative programming;
in functional reactive programming (discussed in the next chapter),
  arguments of functions must be copied or moved;
in general Rust shows us that for async programming, move semantic is more suitable;

scenarios that involve returning refs often require explicit lifetimes;
  so don't return refs, instead use mutable refs in inputs;
structs and enums containing refs must have explicit lifetimes;
  so don't use them;

shared mutability for fixed sized data (called interior mutability)
  can be done statically using "Cell";
if the size is not fixed, a runtime solution is needed (RefCell);
note that "Cell" and "RefCell" can work only in a single thread;
  use "RwLock" for multiple threads;

RC: shared owning (a runtime solution);
ARC: multi_threaded;

Rust have separate types for static and dynamic values; (str/String, fn/Fn)
static data can be defined using only other static data;
functions can only access static environment;
  closures don't have this limitation; so when using them we must be more careful;

s: String -> &s: &String -> &s[..]: &str
v: Vec<T> -> &v: &Vec<T> -> &v[..]: &[T]
&str and &[T] are slices; str and [T] are unsized types;
slicing is like borrowing from an unsized type;
since the the slice contains the size, the lending type itself doesn't need to have a definite size;

x = a[i] -> this is possible if the elements of "a" are copy
  (cause moving out of collections is not possible);
x = &a[i] -> this is for the case when the elements are not copy;
x = a[i..j] -> this is always invalid;
x = &a[i..j] -> slicing;

auto ref/deref for self in method calls:
  insert as many * or & as necessary to get it right;
cause in method calls name and context of a method call is almost always sufficient
  to infer the move/borrow semantics;

deref coercion:
, &T -> &U when T: Deref<Target=U>
, &mut T -> &U when T: Deref<Target=U>
, &mut T -> &mut U when T: DerefMut<Target=U>
examples:
  &&i32 -> &i32 because &i32: Deref<Target=i32>
  &String -> &str because String: Deref<Target=str>
  &Vec<T> -> &[T] because Vec<T>: Deref<Target=[T]>
= type system
types show us what we can do with the data (which operations are valid);

the class hierarchy design like in Java is problematic;
  "http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html"
also the problem of covariance for generic types, has its root in this problem;
  "https://en.wikipedia.org/wiki/Wildcard_(Java)"
i think this is also the motivation for dynamic typing (another bad design);
the right way as done in Rust, Go and Julia:
, concrete types (like final classes in Java) can be instantiated, but cannot have subtypes;
, abstract types (like abstract classes in Java) cannot be instantiated, but can have subtypes;

dot notation is used where we can destucture (tuples, structures);
double colon "::" is for namespacing;
note that "x.m()" is method call syntax, which completely differs from "(x.m)()";

arrays like tuples have fixed size and are copy;
  but since they are homogeneous (all elements are of the same type), indexing can be done at runtime;
vectors and hash tables are homogeneous, varying sized collection;

Rust does not have named arguments and named tuples; and it's a good thing;
when you need functions with lots of arguments, or tuples with lots of elements,
  it could indicate that you need to restructure your code and use structs to define new types;
