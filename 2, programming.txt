= computers
cpu, memory, peripherals,
  this seems to be the only practical architecture for the hardware of computers;
cpu runs a sequence of simple computations called instructions (packages of 0 and 1),
  one by one;

compilers are special programs that obtain computer instructions
  from a program written in a language which is structured and human readable;
  this way the written program will be portable to different computer architectures;
Rust is a programming language which provides zero cost abstractions,
  and memory safety without garbage collection;
  thus there is absolutely no reason to write new software in C/C++;

programs usually do not run directly on computer hardware;
instead they run on a more sophisticated software machine (a virtual machine) called the kernel;
in theory we can live without a kernel (an idea sometimes called a library operating system);
but in that case, we have to rewrite all the required libraries, on bare metal;
in addition since  we can't have more than one program,
  to develop and test new programs on such a system, we need hot_pluggable libraries;
  "https://github.com/draivin/rust-hotswap"

Linux is a highly developed, constantly evolving, open_source kernel;
"https://dominuscarnufex.github.io/cours/rs-kernel/en.html"
in Linux (and other Unix based operating systems) most things appear in the file system;
  i think the reason is to make it possible to do a lot of things using shell scripts
    instead of a proper programming language;
  while i can understand the convenience it provides, i don't think it's good design;

= Rust
Rust makes bad programming hard, and good programming fun;
Rust does not hide (inherent) complexity, in fact it bolds it, so we can see it, and avoid it;
by inherent complexity i mean a complexity which can not be abstracted away completely;
  ie if we attempt to hide it, it will re_emerge somewhere else;
in fact, hiding inherent complexity usually leads to choosing the wrong approach;

for example, references (sharing data) are problematic in two situations:
, data structures made of references (eg a closure capturing a reference);
, mutable sharing (eg GUI widgets put in containers);
most programming languages hide these problems behind runtime solutions like garbage collection;
but the right approach is to simply avoid them, or at least make their usage controlled and limited;
"https://manishearth.github.io/blog/2015/05/17/the-problem-with-shared-mutability/"

static data (functions, structs, constants): no problem, copy or share by reference;
dynamic data: can have fixed structure, or dynamic structure;
, if data has a fixed structure we usually put it on stack;
  so we don't share it across the program, we copy it;
  if the data is big and we want to share it, we can put it inside a cell on the heap,
    and share references to it across the program, using &;
  since the structure of data is fixed we can mutate it from anywhere (in the same tread);
, but in general where the structure of data is not fixed,
  we need to check if the read_write_lock pattern is fulfilled,
  either statically (when sharing refs using &mut),
  or dynamically at runtime, by putting it inside a RefCell
    (or its multi_threaded counterparts: Mutex or RwLock);
  note that if runtime read_write_lock pattern fails, the program will panic;
  this is true even for garbage collected languages,
    and can be seen in rare occasions like iteration invalidation;
    you see? inherent complexities can't be hidden completely;

a type is "Copy" if all the data it owns is part of its stack representation;
  in other words if a copy of its stack representation doesn't violate memory safety;
"&T" and raw pointers are "Copy", "&mut T" isn't "Copy" (it's "Move");

in Rust any resource have exactly one owner which takes care of its resource deallocation;
owners can share their data by lending them to references;
references must have a lifetime less than the owner;
furthermore lifetime of a mutable reference must not overlap with other references;
"http://blog.skylight.io/rust-means-never-having-to-close-a-socket/"

owner can:
, access and mutate resource;
, lend the resource to a reference;
, hand over ownership (move), or deallocate resource;
but during a lend, owner can't:
, mutate the resource;
, mutably lend resouce to another reference;
, hand over ownership (move), or deallocate resource;
and during a mutable lend, owner can't even access the resource;

references (shared references) can:
, access borrowed resource;
, immutably lend resource to other references;
mutable reference (exclusive reference) can:
, access and mutate resource;
, mutably lend resouce to another reference;
  they can immutably lend resource, but then they can mutate it;
  just like when an owner immutably lends its resource;

during shared borrow (immutable borrow) no one owns the data;
  so even the original owner can't change it;
during mutable borrow the (unique) borrower owns it;
so "&mut" is actually a temporary transfer of ownership;

runtime borrow check: RefCell (or its multi_threaded counterparts: Mutex or RwLock);
runtime memory management (owner check): Rc (or its multi_threaded counterpart: Arc);

structs and enums containing refs must have explicit lifetimes; so don't use them;
one situation that they seem unavoidable is async sharing (ie closures capturing references);
async sharing needs runtime checking (as opposed to sync sharing which can be checked statically);
  so it's better to move/copy in async situations;

scenarios that involve returning refs often require explicit lifetimes;
  so don't return refs, instead use mutable refs in inputs;

s: String -> &s: &String -> &s[..]: &str
v: Vec<T> -> &v: &Vec<T> -> &v[..]: &[T]
&str and &[T] are slices; str and [T] are unsized types;
slicing is like borrowing from an unsized type;
since the the slice contains the size, the lending type itself doesn't need to have a definite size;

x = a[i] -> this is possible if the elements of "a" are copy
  (cause moving out of collections is not possible);
x = &a[i] -> this is for the case when the elements are not copy;
x = a[i..j] -> this is always invalid;
x = &a[i..j] -> slicing;

auto ref/deref for self in method calls:
  insert as many * or & as necessary to get it right;
because in method calls name and context of a method call is almost always sufficient
  to infer the move/borrow semantics;

deref coercion:
, &T -> &U when T: Deref<Target=U>
, &mut T -> &U when T: Deref<Target=U>
, &mut T -> &mut U when T: DerefMut<Target=U>
examples:
  &&i32 -> &i32 because &i32: Deref<Target=i32>
  &String -> &str because String: Deref<Target=str>
  &Vec<T> -> &[T] because Vec<T>: Deref<Target=[T]>
"https://github.com/rust-lang/rfcs/blob/master/text/0241-deref-conversions.md"

= type system
types show us what we can do with the data, ie which operations are valid;

the class hierarchy design, eg in Java, is problematic;
  "http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html"
also the problem of covariance for generic types, has its root in this problem;
  "https://en.wikipedia.org/wiki/Wildcard_(Java)"
i think this problem is also the motivation for dynamic typing (another bad design);
the right way as done in Rust, Go and Julia:
, concrete types (like final classes in Java) can be instantiated, but cannot have subtypes;
, abstract types (like abstract classes in Java) cannot be instantiated, but can have subtypes;

note that "x.m()" is method call syntax, which completely differs from "(x.m)()";

in "use" statements:
, crate_name::...
, self::local_item::...
even outside "use" statements, we can build absolute paths using crate names at the begining;
  but since it can conflict with a local name, it's better to avoid it, and instead,
  either insert a "::" at the begining, before the crate's name,
  or bring the crate's name into scope using a "use" statement;

arrays like tuples have fixed size and thus stored on stack;
  but since they are homogeneous (all elements are of the same type), they can be indexed at runtime;
vectors and hash tables are homogeneous, varying sized collections;

Rust does not have named arguments and named tuples; and it's a good thing;
when you need functions with lots of arguments, or tuples with lots of elements,
  it's a sign that you need to restructure your code, and use structs to define new types;

a closure is like an anonymous struct made of variables captured from environment,
  that is callable (implements Fn/FnMut/FnOnce trait);
so all closures are unique types, but they have traits in common;
note that if we put a generic type parameter in the return type of a fuction,
  we have to provide the concrete type when we call the function;
  thus we can't use generic type parameters to return a closure, we have to use "impl";

"fn(T1) -> T2" is not an unsized type like "str", it's a function pointer;

= actors
actors can help us to avoid mutable sharing, and control async sharing;
"https://crates.io/crates/may_actor"

an actor can have a set of parameters which can be adjusted based on the recieved messages;
  this can be used to implement learning capabilities;
