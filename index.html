
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset='utf-8'>
  <title>Comshell</title>
  
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font/build/web/hack.css'>
  <style>
    body {
      padding: 50px;
      margin: 0;
      font-family: Hack;
      font-size: 14px;
      max-width: 750px;
      white-space: pre-wrap;
    }
    div {
      margin-left: 14px;
      text-indent: -14px;
    }
  </style>
  
  </head>
  
  <body><h1>Comshell</h1>
<h2>1, Comshell</h2><div>Comshell is a command based user interface, written in Julia using Reactive.jl.</div><div><p></p></div><div>command based user interfaces (using keyboard, voice, gesture) are faster, more convenient and more powerful than pointing based user interfaces (using mouse, touch, pen).</div><div>touch interfaces can still be useful in simple limited applications. and for some special artistic applications, pen input remains the only choice.</div><div>command based interactions are much simpler for a speech recognition engine to process, since it needs to match against a relatively small set of commands, unlike a general speech recognition process.</div><div>a headset with near range microphone can be used, to exclude far away sound sources. also it is better to put battery and bluetooth of the headset in a separate unit, that can be put in the pocket. this makes the headset lighter and safer.</div><div>for those that neither can use all their fingers, nor can talk, gesture based (2d) input can be implemented.</div><div><p></p></div><div><img src='keyboard.png' alt='keyboard.png'/></div><div>missing characters can be entered using snippets:</div><div>, two commas --&gt; .</div><div>, comma followed by ' --&gt; "</div><div>, comma followed by ( --&gt; [</div><div>, comma followed by add followed by comma --&gt; +</div><div>, comma followed by add followed by space --&gt; + followed by space</div><div>, comma followed by psi followed by space --&gt; Ïˆ followed by space</div><div>, two apostrophes followed by a --&gt; A</div><div><p></p></div><div>Vim'like key'bindings</div><div>modes (like normal mode and insert mode) must be visually distinctive.</div><div>press "esc" to go back to normal mode.</div><div>in normal mode:</div><div>, create a new project or file</div><div>, show list of projects or files, move between files (previous, next), and then press space to open or raise them, or directly go to them by entering their number</div><div>, move the cursor to the next or previous (or by entering the number directly to) words, lines (or table cells), paragraphs</div><div>, start and end selection, then copy or cut</div><div>, paste</div><div>, undo, redo</div><div>, find</div><div>, enter insert mode</div><div><p></p></div><div>projects are looked for in "~/projects/" and all directories named "projects" on all disks. from this list of projects, we can open them or switch to them if they are already open.</div><div>different views of the current project can be opened in separate tabs.</div><div>external projects (which can also be websites, pdf, etc) are opened from inside the current project (not from projects list), and are located in an adjacent tab.</div><div><p></p></div><div>a panel at the left shows a tree view of the files in the project.</div><div>text files open in a text editor panel at the right.</div><div>directories with ".m" extension open in a panel at the right, showing thumbnails of the files in it.</div><div><p></p></div><div>focus paragraph, i'e auto scroll to reveal whole paragraph.</div>
<h2>2, computers</h2><div>computers are programmable systems.</div><div><p></p></div><div>in conventional digital circuits when the inputs change the outputs can have temporary incorrect values until they stabilize to correct values. so gates with memory, must be synchronized with a global clock signal. the period of clock signal is made long enough for the circuit to become stable.</div><div>this forces us to split long operations into several smaller ones which can be performed in successive clock cycles (a technique known as pipelining). otherwise the circuit would be slow and inefficient.</div><div>in addition the widely distributed clock signal takes a lot of power, and must run whether the circuit is receiving inputs or not.</div><div>the solution is to use rendezvous channels, in which sends and receives, block until the other side is ready.</div><div>initially all channels have default values (this is necessary to cope with feedbacks). then gates start to fetch their inputs from channels and compute their output values. and when their following gates are ready to receive it, they send it to the output channels. now the gate itself is ready to receive new values on its inputs.</div><div><p></p></div><div>cpu, memory, peripherals, this seems to be the only practical architecture for the hardware of computers. though universal memory technologies (like magneto'resistive random'access memory) if possible, could make things simpler.</div><div>cpu runs a sequence of simple computations called instructions (packages of 0 and 1), one by one.</div><div><p></p></div><div>programs usually do not run directly on a computer hardware, instead they run on a more sophisticated software machine (a virtual machine) called kernel.</div><div>Linux is an example. one thing that i don't like about it (and indeed other Unix based operating systems) though is that most things appear in the file system. i think the reason is to make it possible to do a lot of things using shell scripts instead of a proper programming language, and i think it's a bad idea.</div><div><p></p></div><div>compilers are special programs that obtain computer instructions from a program written in a language which is human readable and structured. this way the written program will be portable to different computer architectures.</div><div><p></p></div><div><b>type system</b></div><div>types show us what we can do with the data (which operations are valid).</div><div><p></p></div><div><a href='https://julialang.org/'>https://julialang.org/</a></div><div><p></p></div><div>data constructors:</div><div>A :: (Int, Str) -&gt; A</div><div>enums:</div><div>X :: Int -&gt; B</div><div>Y :: (Int, Int) -&gt; B</div><div><p></p></div><div>function definition:</div><div>f = (x, y) -&gt; "chain of function applications"</div><div>other than bindings defined externally, we can use bindings defined locally (using where keyword).</div><div><p></p></div><div>multiple bindings using pattern matching</div><div><p></p></div><div>interfaces:</div><div>f :: (Int, I) -&gt; Int</div><div>g :: I -&gt; Str</div><div>A :: (Int, Str) -&gt; A</div><div>f :: (Int, A) -&gt; Int</div><div>  = (x, A(y, z)) -&gt; x + y</div><div>g :: A -&gt; Str</div><div>  = A(x, y) -&gt; concat[y, "asd"]</div><div><p></p></div><div>tuples (heterogeneous, fixed size module system):</div><div>x = (a, b)</div><div>to access internal values: x.1 (literal number only)</div><div>named elements: (i = a, j = b)</div><div>and for indexing: x.i</div><div>private fields are indicated by an underline: (_i = a, j = b)</div><div>polymorphic field names: (i::T1 = a, i::T2 = b)</div><div>in fact, modules are tuples too. since the elements of a module are all written at the first column (without indentation), we can safely omit parentheses and commas.</div><div><p></p></div><div>arrays (homogeneous, varying sized collection):</div><div>x = [a, b]</div><div>indexing: x:i</div><div>note that if "x" is an array of integers, type of "x:i" is not "Int", it's "Maybe Int".</div><div>hash table: ["a" =&gt; a, "b" =&gt; b]</div><div>for string type keys, an alternative form is: [a = a, b = b]</div><div>and for indexing: x:"a"</div>
<h2>3, f'r'p</h2><div>imperative programming is done by procedurally changing stored values, it resembles the way cpu runs the instructions stored in memory.</div><div>imperative programming leads to unmaintainable code in large programs, and it makes writing parallel programs a cumbersome task.</div><div><p></p></div><div>functional reactive programming:</div><div>when the output channels of a function is empty and the input channels are full, the function consumes its inputs and fills its outputs with computed values.</div><div>initially all channels have default values, so feedbacks are possible.</div><div><p></p></div><div>functions just compute new data, they don't change anything outside of the function. but many computations need to mutate the data given to them, because the data is big and copying it would be inefficient.</div><div>one method as seen in languages like Haskell and Clojure is to use persistent data structures. in this method only the mutated part of data is computed and the rest of data is accessed through a reference to the original data. this may introduce some efficiency costs, but more importantly this method needs garbage collection.</div><div>another method is to use value semantics and copy'on'write as in Swift. this method introduces some run'time cost because of reference counting. (it's actually a run'time solution)</div><div>another method is to use move semantics (also known as uniqueness or linear types), as used in LinearML, Mercury and Rust. (note that none of these languages need run'time garbage collection)</div><div>but if a unique value is used more than once in the code, it means that there must be separate copies. thus to prevent the need to copy data, we can see the need for a garbage collection enters again from the back door.</div><div><p></p></div><div>the real solution:</div><div>, big immutable data (which is logically global, like functions) -&gt; no problem, static life time, one object with multiple references</div><div>, small immutable and mutable data -&gt; just copy it</div><div>, big mutable data -&gt; keep it in a local state loop, mutate it locally</div><div>in other words, don't trasfer mutable big data. keep it in a local state loop, change it by sending small data as well as immutable big data.</div><div>this way there is no need for garbage collection.</div><div><p></p></div><div><a href='http://juliagizmos.github.io/Reactive.jl/'>http://juliagizmos.github.io/Reactive.jl/</a></div><div><p></p></div><div>passing data across functions:</div><div>, copy (for small primitive data)</div><div>, borrow (immutable, lifetime is known at compile'time)</div><div>, counted reference (immutable, lifetime is unknown at compile'time)</div><div>, move (for linear type data, in'place mutability is possible)</div><div><p></p></div><div>"Henry G Baker, use'once variables and linear objects":</div><div>programming languages should have use'once variables in addition to the usual multiple'use variables. use'once variables are bound to linear (unshared, unaliased, or singly'referenced) objects. linear objects are cheap to access and manage, because they require no synchronization or tracing garbage collection. linear objects can elegantly and efficiently solve otherwise difficult problems of functional systems, e'g in'place updating and the efficient initialization of functional objects.</div><div>a use'once variable must be dynamically referenced exactly once within its scope. unreferenced use'once variables must be explicitly killed, and multiply'referenced use'once variables must be explicitly copied. use'once variables are bound only to linear objects, which may reference other linear or non'linear objects. non'linear objects can reference other non'linear objects, but can reference a linear object only in a way that ensures mutual exclusion.</div><div>linear objects and use'once variables map elegantly into dataflow models of concurrent computation. and the graphical representations of dataflow models make an appealing visual linear programming language.</div><div>the acceptance by a function of a linear argument object places a great responsibility on the function. the function must either pass the linear object to another function as an argument, explicitly dispose of it, or return it as a return value.</div><div>a linear language is ideal for a dataflow architecture, which must explicitly duplicate/delete (linear) tokens.</div><div><p></p></div><div><b>Rust</b></div><div><a href='http://notes.willcrichton.net/rust-the-new-llvm/'>http://notes.willcrichton.net/rust-the-new-llvm/</a></div><div>new programming languages with a system'level compile target should choose Rust over LLVM. targeting Rust can give new languages free package management, a type system, and memory safety, while not imposing too many opinions on the language's runtime.</div><div><p></p></div><div>Rust has a good designed type system.</div><div>the class hierarchy design like in Java is problematic.</div><div>    <a href='http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html'>http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html</a></div><div>also the problem of covariance for generic types, has its root in this problem.</div><div>    <a href='https://en.wikipedia.org/wiki/Wildcard_(Java)'>https://en.wikipedia.org/wiki/Wildcard_(Java)</a></div><div>the right way is to use structs and traits:</div><div>, structs are like final classes in Java, we use them to make object, but we can't inherit other classes from them.</div><div>, traits are like abstract classes in Java, we can inherit other classes from them, but we can't directly use them to make objects.</div><div>this way, all non'leaf classes will be abstract (traits), and all leaf classes will be final (structs).</div><div><p></p></div><div>shared mutability is the root of many complexities, especially in concurrent environments.</div><div>Rust tracks and controls shared mutability. in Rust as long as a piece of data can be changed within a code segment (i'e there is a mutable reference to the data), no other code path can read or modify the same data.</div><div>all references in Rust must either be unique or immutable.</div><div><p></p></div><div><a href='https://doc.rust-lang.org/stable/book/second-edition/index.html'>https://doc.rust-lang.org/stable/book/second-edition/index.html</a></div><div><a href='https://rustbyexample.com/'>https://rustbyexample.com/</a></div><div><a href='http://blog.skylight.io/rust-means-never-having-to-close-a-socket/'>http://blog.skylight.io/rust-means-never-having-to-close-a-socket/</a></div><div><p></p></div><div>heap is necessary for:</div><div>, growable data</div><div>, sharing data between distinct software processes (functions and threads)</div><div>for the compiler to know where memory should be freed at compile'time, Rust uses stack based memory, and uses only uniquely'owned heap'allocated box. (heap memory with multiple owners needs garbage collection)</div><div>in Rust there are two kinds of refs, owner and borrower. borrowers must have a lifetime less than the owner.</div><div>any resource have exactly one owner which takes care of its resource deallocation.</div><div><p></p></div><div>owner can:</div><div>, control resource deallocation</div><div>, lend the resource:</div><div>  , immutably (multiple borrows)</div><div>  , mutably (exclusive)</div><div>, hand over ownership (move)</div><div>owner can't:</div><div>, during borrow:</div><div>  , mutate the resource</div><div>  , mutably lend the resource</div><div>, during mutable borrow:</div><div>  , access the resource</div><div>  , lend the resource</div><div>borrower can:</div><div>, access borrowed resource</div><div>, share (copy) an immutable borrow</div><div>mutable borrower can:</div><div>, access and mutate resource</div><div>, hand over (move) the mutable borrow (mutable ref is moved by default)</div><div><p></p></div><div>scenarios that involve multiple refs or returning refs often require explicit lifetimes. so don't return refs, instead use mutable refs in inputs.</div><div>structs and enums containing refs must have explicit lifetimes. (impl of these must use lifetimes too)</div><div>make sure that a closure will never outlive the variables it has refs to.</div><div><p></p></div><div><p></p></div><div>Rust have separate types for static and dynamic values. (str/String, fn/Fn)</div><div>functions can only access static environment. closures don't have this limitation. so when using them we might be more careful.</div><div>static data can be defined using only other static data.</div><div><p></p></div><div>arrays must be mutable. thus they must be implemented on stack (not static like str). so the size must be part of the type. (changes in the array must not change its size)</div><div>arrays coerce to slice refs. use slice refs instead of arrays.</div><div><p></p></div><div>unsized types (slices):</div><div>there is no way to know the size of a variable of these types, so they can not be copied nor moved. we can only borrow them.</div><div>unsized (on stack or static) types --&gt; borrow</div><div>sized (on stack or static) types --&gt; copy, borrow</div><div>heap --&gt; move, borrow, copy</div><div><p></p></div><div>String[..] &lt;--&gt; str</div><div>       |</div><div>       |--&gt; slicing</div><div>&String[..] &lt;--&gt; str</div><div>        |</div><div>        |--&gt; deref</div><div><p></p></div><div>automatic referencing in method calls (auto'borrow for self)</div><div><p></p></div><div>Rust auto'dereferences variables when:</div><div>, making method calls on a reference</div><div>, passing a ref as a function arg (because the type sig for functions are mandatory)</div><div>you have to deref vars when:</div><div>, assigning to them without type annotation</div><div>, using overloaded operators</div><div><p></p></div><div>auto'deref:</div><div>if x doesn't implement foo() but implements Deref then x.foo() --&gt; x.deref().foo()</div><div><p></p></div><div><b>Frem to Rust</b></div><div><a href='https://github.com/nikomatsakis/lalrpop'>https://github.com/nikomatsakis/lalrpop</a></div><div><a href='https://github.com/nikomatsakis/lalrpop/blob/master/doc/tutorial.md'>https://github.com/nikomatsakis/lalrpop/blob/master/doc/tutorial.md</a></div><div><a href='https://limpet.net/mbrubeck/2014/08/08/toy-layout-engine-1.html'>https://limpet.net/mbrubeck/2014/08/08/toy-layout-engine-1.html</a></div><div><a href='https://doc.rust-lang.org/book/macros.html'>https://doc.rust-lang.org/book/macros.html</a></div><div><a href='https://github.com/willcrichton/lia'>https://github.com/willcrichton/lia</a></div><div><a href='https://github.com/gluon-lang/gluon'>https://github.com/gluon-lang/gluon</a></div><div><a href='https://github.com/gluon-lang/gluon/blob/master/TUTORIAL.md#embedding-api'>https://github.com/gluon-lang/gluon/blob/master/TUTORIAL.md#embedding-api</a></div><div><a href='https://github.com/gluon-lang/gluon/blob/master/src/regex_bind.rs'>https://github.com/gluon-lang/gluon/blob/master/src/regex_bind.rs</a></div><div><a href='https://github.com/gluon-lang/gluon/tree/master/parser/src'>https://github.com/gluon-lang/gluon/tree/master/parser/src</a></div><div><a href='https://www.reddit.com/r/rust/comments/4bipgm/writing_a_compiler_in_rust/'>https://www.reddit.com/r/rust/comments/4bipgm/writing_a_compiler_in_rust/</a></div><div><p></p></div><div><b>implementing functional reactive programming</b></div><div>in software, there is a limited number of central processing units (unlike in hardware where there is distinct processing units). so we use an event'loop and thread pool to implement functional reactive programming.</div><div><a href='https://tokio.rs/docs/going-deeper-futures/synchronization/#channels'>https://tokio.rs/docs/going-deeper-futures/synchronization/#channels</a></div><div><a href='https://tokio.rs/docs/going-deeper-futures/futures-model/'>https://tokio.rs/docs/going-deeper-futures/futures-model/</a></div><div><a href='http://asquera.de/blog/2017-03-01/the-future-with-futures/'>http://asquera.de/blog/2017-03-01/the-future-with-futures/</a></div><div><a href='https://docs.rs/futures/0.1.13/futures/'>https://docs.rs/futures/0.1.13/futures/</a></div><div><a href='https://docs.rs/futures/0.1.13/futures/stream/index.html'>https://docs.rs/futures/0.1.13/futures/stream/index.html</a></div><div><a href='https://docs.rs/futures/0.1.13/futures/stream/trait.Stream.html'>https://docs.rs/futures/0.1.13/futures/stream/trait.Stream.html</a></div><div><a href='https://docs.rs/futures/0.1.13/futures/sync/mpsc/struct.Receiver.html'>https://docs.rs/futures/0.1.13/futures/sync/mpsc/struct.Receiver.html</a></div><div><a href='https://docs.rs/futures-cpupool/0.1.5/futures_cpupool/'>https://docs.rs/futures-cpupool/0.1.5/futures_cpupool/</a></div><div><a href='https://docs.rs/fibers/0.1.6/fibers/'>https://docs.rs/fibers/0.1.6/fibers/</a></div><div><a href='https://docs.rs/bus/1.3.1/bus/'>https://docs.rs/bus/1.3.1/bus/</a></div>
<h2>4, graphics</h2><div><a href='https://github.com/JuliaGL/GLVisualize.jl'>https://github.com/JuliaGL/GLVisualize.jl</a></div><div><p></p></div><div>software rendering gives us a lot more flexibility, since we are not any more limited by a hardware implementation with triangle only rasterization, isolated shader programs, and fixed size buffers.</div><div><p></p></div><div><a href='https://www.siggraph.org/education/materials/HyperGraph/scanline/outprims/drawline.htm'>https://www.siggraph.org/education/materials/HyperGraph/scanline/outprims/drawline.htm</a></div><div><a href='https://en.wikipedia.org/wiki/Bresenham's_line_algorithm'>https://en.wikipedia.org/wiki/Bresenham's_line_algorithm</a></div><div><a href='https://en.wikipedia.org/wiki/Midpoint_circle_algorithm'>https://en.wikipedia.org/wiki/Midpoint_circle_algorithm</a></div><div><a href='https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm'>https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm</a></div><div><a href='http://members.chello.at/~easyfilter/bresenham.html'>http://members.chello.at/~easyfilter/bresenham.html</a></div><div><a href='https://nothings.org/gamedev/rasterize/'>https://nothings.org/gamedev/rasterize/</a></div><div><p></p></div><div>graphical objects are made of primitives. primitives are defined using a set of</div><div>parameters. each primitive has a specific algorithm for rasterization.</div><div>2d primitives: point, line, curve, triangle, curved area.</div><div>3d objects made of flat surfaces will be broken up into triangles.</div><div>3d objects made of curved surfaces can be broken up into a number of primitive 3d surfaces which can be easily projected to 2d.</div><div><a href='https://en.wikipedia.org/wiki/Quadric'>https://en.wikipedia.org/wiki/Quadric</a></div><div>also interpolation is a good method for amorphous surfaces.</div><div><p></p></div><div>2d objects will be rasterized to pixels (i'e a coordinate and a color value).</div><div>then these rasterized objects will be drawn in the framebuffer, in layers over each other (in an overlay on top of all 3d objects).</div><div>rasterizing 3d objects, produces an array of fragments. a fragment other than color, contains a normal and a depth.</div><div>when creating the pixels of the framebuffer from the fragments, the normals are used for lighting, and the depths are used for z'buffer.</div><div><p></p></div><div><a href='https://en.wikipedia.org/wiki/Stencil_buffer'>https://en.wikipedia.org/wiki/Stencil_buffer</a></div><div><a href='https://www.scratchapixel.com'>https://www.scratchapixel.com</a></div><div><a href='https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF'>https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF</a></div><div><p></p></div><div>graphical objects are of 2 kinds:</div><div>, those which we know will remain unchanged the next time we want to draw to the framebuffer. these objects are first rasterized into memory, then we copy it to framebuffer.</div><div>, those which we know will be changed (scaled, rotated, moved in z direction) the next time we want to draw to the framebuffer (which happens a lot for animations with high frame rate). these objects will be drawn directly to the framebuffer.</div><div>(framebuffer uses double buffering and v'sync)</div><div>note that if an object just moves in x'y plane (without rotation), the cached rasterization is still useful. for 2d objects we simply add a constant to the position of all pixels. for 3d objects we may additionally want to recompute the lighting of pixels form fragments.</div><div><p></p></div><div>graphical objects:</div><div>, primitives</div><div>, material</div><div>, cached rasterization (can be none)</div><div><p></p></div><div>graphical objects can be put in a layout tree. transformations on objects will be applied in groups, based on the tree.</div><div>objects are moved to the tree. they can be accessed only by their index. it means that, unlike in a scene'graph, pointers to objects in the tree are not accessible by the user. they are accessed only using tree indexing. so there are no free pointers, and no need for run'time memory management.</div><div><p></p></div><div>we define transformation functions which trasnform states.</div><div>transformation :: State -&gt; State</div><div>                  --------</div><div>transformation--&gt;|        |</div><div>                 |        |----&gt; state</div><div>               -&gt;|        |  |</div><div>              |   --------   |</div><div>               --------------</div>
<h2>url</h2><div><a href='https://github.com/damoonsaghian/Comshell'>https://github.com/damoonsaghian/Comshell</a></div><div><p></p></div><div>this project is licensed under Creative Commons BY-SA.</div><div><a href='http://creativecommons.org/licenses/by-sa/4.0/'>http://creativecommons.org/licenses/by-sa/4.0/</a></div></body></html>