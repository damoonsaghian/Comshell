
<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<title>Comshell
</title>

<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro' rel='stylesheet'>
<style>
  body {
    padding: 1em;
    margin: 0;
    font-family: 'Source Code Pro', monospace;
    font-size: 1em;
    max-width: 50em;
    white-space: pre-wrap
  }
  div {
    margin-left: 1em;
    text-indent: -1em;
  }
</style>

</head>

<body>
<h1>Comshell
</h1>
<a href='https://github.com/damoonsaghian/Comshell
'>https://github.com/damoonsaghian/Comshell
</a>
<h2>1, command based user interface</h2><div>command based user interfaces (using keyboard, voice, gesture) are faster more convenient and more powerful than pointing based user interfaces (using mouse, touch, pen).</div><div>pointing interfaces can be useful only for very simple tasks. also for some special artistic applications pen input remains the only choice.</div><div><p></p></div><div><img src='keyboard.png' alt='keyboard.png'/></div><div>, two commas --&gt; .</div><div>, comma followed by ' --&gt; "</div><div>, comma followed by ( --&gt; [</div><div>, comma followed by add followed by comma --&gt; +</div><div>, comma followed by add followed by space --&gt; + followed by space</div><div>, comma followed by psi followed by space --&gt; Ïˆ</div><div>, two apostrophies followed by a --&gt; A</div><div><p></p></div><div>Vim'like key'bindings</div><div>modes (like normal mode and insert mode) must be visually distinctive.</div><div>pressing "esc" key always take you back to normal mode.</div><div>in normal mode we can:</div><div>, create a new project or chapter</div><div>, show projects or chapter, move between them (previous, next), and then press space to open or raise them, or directly go to them by entering their number</div><div>, move the cursor to the next or previous (or by entering the number directly to) words, lines (or table cells), paragraphs, pages</div><div>, start and end selection, then copy or cut</div><div>, paste</div><div>, undo, redo</div><div>, find</div><div>, enter insert mode</div><div><p></p></div><div>command based interactions are much simpler for a speech recognition engine to process, since it needs to match against a relatively small set of commands, unlike a general speech to text process.</div><div>a headset with near range microphone can be used, to exclude far away sound sources. also it is better to put battery and bluetooth of the headset in a separate unit, that can be put in the pocket. this makes the headset lighter and safer.</div><div>for those that neither can use all their fingers, nor can talk, gesture based interface can be implemented.</div><div><p></p></div><div>Comshell is a command based user interface, being developed using Rust ecosystem.</div>
<h2>2, graphics</h2><div>software rendering gives us a lot more flexibility, since we are not any more limited by a hardware implementation with triangle only rasterization, isolated shader programs, and fixed size buffers.</div><div>font-rs <a href='https://github.com/google/font-rs'>https://github.com/google/font-rs</a></div><div><a href='https://docs.rs/rusterize/'>https://docs.rs/rusterize/</a></div><div><a href='https://docs.rs/softrender/'>https://docs.rs/softrender/</a></div><div><a href='https://crates.io/crates/line_drawing'>https://crates.io/crates/line_drawing</a></div><div><a href='https://www.siggraph.org/education/materials/HyperGraph/scanline/outprims/drawline.htm'>https://www.siggraph.org/education/materials/HyperGraph/scanline/outprims/drawline.htm</a></div><div><a href='https://en.wikipedia.org/wiki/Bresenham's_line_algorithm'>https://en.wikipedia.org/wiki/Bresenham's_line_algorithm</a></div><div><a href='https://en.wikipedia.org/wiki/Midpoint_circle_algorithm'>https://en.wikipedia.org/wiki/Midpoint_circle_algorithm</a></div><div><a href='https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm'>https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm</a></div><div><a href='http://members.chello.at/~easyfilter/bresenham.html'>http://members.chello.at/~easyfilter/bresenham.html</a></div><div><a href='https://nothings.org/gamedev/rasterize/'>https://nothings.org/gamedev/rasterize/</a></div><div><p></p></div><div>graphical objects are made of primitives. primitives are defined using a set of parameters. each primitive has a specific algorithm for rasterization.</div><div>2d primitives: point, line, curve, triangle, curved area.</div><div>3d objects made of flat surfaces will be broken up into triangles.</div><div>3d objects made of curved surfaces can be broken up into a number of primitive 3d surfaces which can be easily projected to 2d.</div><div><a href='https://en.wikipedia.org/wiki/Quadric'>https://en.wikipedia.org/wiki/Quadric</a></div><div>also interpolation is a good method for amorphous surfaces.</div><div><p></p></div><div>2d objects will be rasterized to pixels (i'e a coordinate and a color value).</div><div>then these rasterized objects will be drawn in the framebuffer, in layers over each other (in an overlay on top of all 3d objects).</div><div>rasterizing 3d objects, produces an array of fragments. a fragment other than color, contains a normal and a depth.</div><div>when creating the pixels of the framebuffer from the fragments, the normals are used for lighting, and the depths are used for z'buffer.</div><div><p></p></div><div><a href='https://en.wikipedia.org/wiki/Stencil_buffer'>https://en.wikipedia.org/wiki/Stencil_buffer</a></div><div><a href='https://www.scratchapixel.com'>https://www.scratchapixel.com</a></div><div><a href='https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF'>https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF</a></div><div><p></p></div><div>graphical objects are of 2 kinds:</div><div>, those which we know will remain unchanged the next time we want to draw to the framebuffer. these objects are first rasterized into memory, then we copy it to framebuffer.</div><div>, those which we know will be changed (scaled, rotated, moved in z direction) the next time we want to draw to the framebuffer (which happens a lot for animations with high frame rate). these objects will be drawn directly to the framebuffer.</div><div>(framebuffer uses double buffering and v'sync)</div><div>note that if an object just moves in x'y plane (without rotation), the cached rasterization is still useful. for 2d objects we simply add a constant to the position of all pixels. for 3d objects we may additionally want to recompute the lighting of pixels form fragments.</div><div><p></p></div><div>graphical objects:</div><div>, primitives</div><div>, material</div><div>, cached rasterization (can be none)</div><div><p></p></div><div>graphical objects can be put in a layout tree. transformations on objects will be applied in groups, based on the tree.</div><div>objects are moved to the tree. they can be accessed only by their index. current object index is where the selection cursor is.</div><div>note that unlike a scene'graph, pointers to objects in the tree, are not accessable by the user. they are accessed only using tree indexing. so there are no free pointers, and no need for run'time memory management.</div><div><p></p></div><div>the data stream sent to the graphics function contains:</div><div>1, the new object to be added beside the currently selected object. (can be none)</div><div>2, the transformation which must be applied to this new object (in which case, the transformation can be none), or to the selected object (if there is no new object).</div><div>3, the index, or the relative motion of the index of currently selected object in the tree.</div>
<h2>3, useful libs</h2><div><a href='https://crates.io/crates/futures'>https://crates.io/crates/futures</a></div><div><p></p></div><div>winit</div><div>evdev (for input) and drm (to access the framebuffer)</div><div><p></p></div><div>text editing:</div><div><a href='https://github.com/jmacdonald/scribe'>https://github.com/jmacdonald/scribe</a></div><div><a href='https://github.com/mathall/rim'>https://github.com/mathall/rim</a></div><div><a href='https://github.com/gchp/iota'>https://github.com/gchp/iota</a></div><div><a href='https://github.com/zovt/tea'>https://github.com/zovt/tea</a></div><div><p></p></div><div>web:</div><div><a href='https://github.com/servo/rust-url/'>https://github.com/servo/rust-url/</a></div><div><a href='https://crates.io/crates/hyper'>https://crates.io/crates/hyper</a></div><div>  <a href='https://crates.io/crates/hyper-rustls'>https://crates.io/crates/hyper-rustls</a></div><div>  <a href='https://crates.io/crates/reqwest'>https://crates.io/crates/reqwest</a></div><div>  <a href='https://crates.io/crates/simplist'>https://crates.io/crates/simplist</a></div><div><a href='https://crates.io/crates/httpbin'>https://crates.io/crates/httpbin</a></div><div><a href='https://crates.io/crates/httpbis'>https://crates.io/crates/httpbis</a></div><div><a href='https://crates.io/crates/xmpp-proto'>https://crates.io/crates/xmpp-proto</a></div><div><a href='https://crates.io/crates/pijul'>https://crates.io/crates/pijul</a> (version control system)</div><div><a href='https://crates.io/crates/github-rs'>https://crates.io/crates/github-rs</a></div><div><p></p></div><div>media:</div><div><a href='https://github.com/pcwalton/rust-media'>https://github.com/pcwalton/rust-media</a></div><div><a href='https://github.com/tomaka/rodio'>https://github.com/tomaka/rodio</a></div><div><a href='https://github.com/tomaka/cpal'>https://github.com/tomaka/cpal</a></div><div><a href='https://crates.io/crates/lewton'>https://crates.io/crates/lewton</a></div><div><a href='https://crates.io/crates/camera_capture'>https://crates.io/crates/camera_capture</a></div><div><a href='https://crates.io/crates/mpv'>https://crates.io/crates/mpv</a></div><div><a href='https://trac.ffmpeg.org/wiki/HWAccelIntro'>https://trac.ffmpeg.org/wiki/HWAccelIntro</a></div>
<h2>4, Atom</h2><div>obviously implementing Comshell is a lot of work. fortunately Atom editor provides an a'p'i which can be used as a temporary solution.</div><div><a href='https://atom.io/docs/api/v1.21.0/AtomEnvironment'>https://atom.io/docs/api/v1.21.0/AtomEnvironment</a></div><div><a href='https://www.sitepoint.com/how-to-write-a-syntax-highlighting-package-for-atom/'>https://www.sitepoint.com/how-to-write-a-syntax-highlighting-package-for-atom/</a></div><div><p></p></div><div>project manager:</div><div>, open files of a project in the current tab (even if it is open in another tab).</div><div>, search all disks for a directory named "projects".</div><div><p></p></div><div>file browser:</div><div>, thumbnails for images an videos</div><div>, select files by typing</div><div>, when a file is opened, a new pane is created at right, showing the file.</div><div>, the active file is always visible and highlighted.</div><div><p></p></div><div>text editor:</div><div>, discrete scrolling</div><div>, do not show incomplete paragraphs.</div><div><p></p></div><div>we can have different views of a project in different tabs.</div><div>make tabs smaller, and visible only if more than one.</div><div><p></p></div><div>external files (websites, pdf, ...) will be opened in a panel which comes up to show the document, and is visible only in that tab. to get back to the editor tab, the panel will be minimized, showing only the title of open documents.</div><div><p></p></div><div>subtitle for videos</div><div><p></p></div><div>see these packages for example:</div><div><a href='https://atom.io/packages/vim-mode-plus'>https://atom.io/packages/vim-mode-plus</a></div><div><a href='https://atom.io/packages/atom-browser'>https://atom.io/packages/atom-browser</a></div><div><a href='https://atom.io/packages/pane-browser'>https://atom.io/packages/pane-browser</a></div><div><a href='https://atom.io/packages/project-plus'>https://atom.io/packages/project-plus</a></div><div><a href='https://atom.io/packages/project-neue'>https://atom.io/packages/project-neue</a></div><div><a href='https://atom.io/packages/project-finder'>https://atom.io/packages/project-finder</a></div><div><a href='https://atom.io/packages/project-jump'>https://atom.io/packages/project-jump</a> (for sorted list)</div><div><a href='https://atom.io/packages/navigate'>https://atom.io/packages/navigate</a></div><div><a href='https://atom.io/packages/project-banner'>https://atom.io/packages/project-banner</a></div><div><a href='https://atom.io/packages/inline-markdown-images'>https://atom.io/packages/inline-markdown-images</a></div><div><a href='https://atom.io/packages/playlist'>https://atom.io/packages/playlist</a></div><div><a href='https://atom.io/packages/atom-music'>https://atom.io/packages/atom-music</a></div><div><a href='https://atom.io/packages/audio'>https://atom.io/packages/audio</a></div><div><a href='https://atom.io/packages/atom-video'>https://atom.io/packages/atom-video</a></div><div><a href='https://atom.io/packages/floobits'>https://atom.io/packages/floobits</a></div><div><a href='https://atom.io/packages/slack-chat'>https://atom.io/packages/slack-chat</a></div><div><a href='https://atom.io/packages/atom-scad-preview'>https://atom.io/packages/atom-scad-preview</a></div><div><a href='https://atom.io/packages/animation-showcase'>https://atom.io/packages/animation-showcase</a></div><div><a href='https://atom.io/packages/maker-ide-atom'>https://atom.io/packages/maker-ide-atom</a></div><div><a href='https://github.com/brrd/Abricotine'>https://github.com/brrd/Abricotine</a></div><div><a href='http://shallowsky.com/blog/linux/editors/graphics-in-emacs.html'>http://shallowsky.com/blog/linux/editors/graphics-in-emacs.html</a></div><div><p></p></div><div>Comshell looks for projects in "~/projects/" and "/projects/".</div><div>a shared project directory can be created like this:</div><div>  mkdir /projects; chmod a+w /projects</div></body></html>