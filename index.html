
  <!DOCTYPE html>
  <html>
  <head>
  <meta charset='utf-8'>
  <title>Comshell</title>
  
  <link rel='stylesheet' href='https://cdn.jsdelivr.net/npm/hack-font@3.3.0/build/web/hack.css'>
  <style>
    body {
      padding: 30px;
      margin: 0;
      font-family: 'Hack';
      max-width: 950px;
      white-space: pre-wrap;
    }
    div {
      margin-left: 19px;
      text-indent: -19px;
    }
  </style>
  </head><body><h1>Comshell</h1>
<h2>1, Comshell</h2><div>Comshell is a command based user interface;</div><div>command based user interfaces (using keyboard, voice, gesture) are faster, more convenient and more powerful than pointing based user interfaces (using mouse, touch, pen);</div><div>although touch interfaces can still be useful in simple limited applications; and for some special artistic applications, pen input remains the only choice;</div><div>unlike a general speech recognition process, voice commands are much simpler for a speech recognition engine to process, since it needs to match against a relatively small set of commands;</div><div>a headset with near range microphone can be used, to exclude far away sound sources; also it is better to put battery and bluetooth of the headset in a separate unit, that can be put in the pocket; this makes the headset lighter and safer;</div><div>for those who neither can use all their fingers, nor can talk, gesture based (2d) input can be implemented;</div><div><p></p></div><div><img src='keyboard.png' alt='keyboard.png'/></div><div>missing characters can be entered like this:</div><div>, two commas --&gt; ;</div><div>, ; followed by comma --&gt; .</div><div>, ; followed by c --&gt; :</div><div>, ; folloed by n --&gt; ::</div><div>, comma followed by add followed by comma --&gt; +</div><div>, comma followed by add followed by space --&gt; + followed by space</div><div>, comma followed by psi followed by space --&gt; Ïˆ followed by space</div><div>, __a --&gt; A</div><div>, ab_cd__ followed by space --&gt; AB_CD followed by space</div><div><a href='https://github.com/adereth/dactyl-keyboard'>https://github.com/adereth/dactyl-keyboard</a></div><div><a href='https://ergodox-ez.com/pages/change-it-yourself'>https://ergodox-ez.com/pages/change-it-yourself</a></div><div><a href='https://shop.keyboard.io/'>https://shop.keyboard.io/</a></div><div>Kinesis Advantage 2 keyboard</div><div><a href='https://github.com/nicinabox/lets-split-guide'>https://github.com/nicinabox/lets-split-guide</a></div><div><a href='http://www.allthingsergo.com/the-best-ergonomic-mechanical-keyboards/'>http://www.allthingsergo.com/the-best-ergonomic-mechanical-keyboards/</a></div><div><p></p></div><div>modal key_bindings;</div><div>modes (like normal mode and insert mode) must be visually distinctive;</div><div>press escape to go back to normal mode;</div><div>in normal mode we can:</div><div>, move the cursor to the next or previous characters or words</div><div>, move the cursor to the next or previous (or by entering the number directly to) lines (or table cells)</div><div>, move the cursor to the next or previous paragraphs</div><div>, start and end selection, then copy or cut</div><div>, paste</div><div>, undo, redo</div><div>, find</div><div>, enter insert mode</div><div><p></p></div><div>projects are looked for in "~/projects/" and all directories named "projects" on all disks; from this list, we can open projects (or switch to them if they are already open); also we can create new projects;</div><div><p></p></div><div>different views of the current project can be opened in separate tabs;</div><div>external projects (which can also be websites, pdf, etc) which are opened from inside the current project (not from projects list) will also be opened in separate tabs;</div><div><p></p></div><div>a panel at the left shows a tree view of the files in the project;</div><div>text files are opened in a text editor panel at the right;</div><div>directories with ".m" extension are opened in a panel at the right, showing thumbnails of the files in it;</div><div>we can go to the panel, and move between files in there (by typing their name), or create new files;</div><div><p></p></div><div>focus paragraph, ie auto scroll to reveal whole paragraph;</div>
<h2>2, computers</h2><div>in conventional digital circuits when the inputs change the outputs can have temporary incorrect values until they stabilize to correct values; so gates with memory, must be synchronized with a global clock signal; the period of clock signal is made long enough for the circuit to become stable;</div><div>this forces us to split long operations into several smaller ones which can be performed in successive clock cycles (a technique known as pipelining); otherwise the circuit would be slow and inefficient;</div><div>in addition the widely distributed clock signal takes a lot of power, and must run whether the circuit is receiving inputs or not;</div><div>the solution is to use rendezvous channels, in which sends and receives, block until the other side is ready;</div><div>initially all channels have default values (this is necessary to cope with feedbacks); then gates start to fetch their inputs from channels and compute their output values; and when their following gates are ready to receive it, they send it to the output channels; now the gate itself is ready to receive new values on its inputs;</div><div><p></p></div><div>cpu, memory, peripherals, this seems to be the only practical architecture for the hardware of computers; though universal memory technologies (like magneto_resistive random_access memory) if possible, could make things simpler;</div><div>cpu runs a sequence of simple computations called instructions (packages of 0 and 1), one by one;</div><div><p></p></div><div>programs usually do not run directly on a computer hardware, instead they run on a more sophisticated software machine (a virtual machine) called kernel;</div><div>Linux is an example; though one thing that i don't like about it (and indeed other Unix based operating systems) is that most things appear in the file system; i think the reason is to make it possible to do a lot of things using shell scripts instead of a proper programming language, and i think it's a bad idea;</div><div><a href='https://github.com/thepowersgang/rust_os'>https://github.com/thepowersgang/rust_os</a></div><div><a href='https://github.com/ryanra/RustOS'>https://github.com/ryanra/RustOS</a></div><div><p></p></div><div>compilers are special programs that obtain computer instructions from a program written in a language which is human readable and structured; this way the written program will be portable to different computer architectures;</div><div>Rust is a programming language which provides zero cost abstractions (eg a well designed type system, and functional programming techniques), and memory safety without garbage collection; thus there is absolutely no reason to write new software in C/C++;</div>
<h2>3, Rust</h2><div>Rust makes bad programming hard, and good programming fun;</div><div>Rust does not hide complexity, in fact it bolds it, so we can see it and avoid it;</div><div><p></p></div><div>evolution of C language:</div><div>, wrong approach:</div><div>  classes (C++)</div><div>  garbage collection:</div><div>    , classes (Java, C#, ...)</div><div>    , immutable data (Haskell)</div><div>, right approach: traits, move semantics (Rust)</div><div><p></p></div><div>shared mutability is the root of many complexities, especially in concurrent environments;</div><div>all references in Rust must either be unique or immutable;</div><div><p></p></div><div>any resource have exactly one owner which takes care of its resource deallocation;</div><div><a href='http://blog.skylight.io/rust-means-never-having-to-close-a-socket/'>http://blog.skylight.io/rust-means-never-having-to-close-a-socket/</a></div><div>owners can share their data by lending them to references; references must have a lifetime less than the owner;</div><div><p></p></div><div>owner can:</div><div>, control resource deallocation</div><div>, lend the resource:</div><div>  , immutably (multiple refs)</div><div>  , mutably (only on ref)</div><div>, hand over ownership (move)</div><div>owner can't:</div><div>, during borrow:</div><div>  , mutate the resource</div><div>  , mutably lend the resource</div><div>, during mutable borrow:</div><div>  , access the resource</div><div>  , lend the resource</div><div><p></p></div><div>reference can:</div><div>, access borrowed resource</div><div>, share (copy) an immutable borrow</div><div>mutable reference can:</div><div>, access and mutate resource</div><div>, hand over (move) the mutable borrow (mutable ref is moved by default)</div><div><p></p></div><div>scenarios that involve multiple refs or returning refs often require explicit lifetimes; so don't return refs, instead use mutable refs in inputs;</div><div>structs and enums containing refs must have explicit lifetimes (impl of these must use lifetimes too); so don't use them;</div><div><p></p></div><div><p></p></div><div>Rust have separate types for static and dynamic values; (str/String, fn/Fn)</div><div>functions can only access static environment; closures don't have this limitation; so when using them we might be more careful;</div><div>static data can be defined using only other static data;</div><div><p></p></div><div>arrays have a fixed size, so they can be implemented on stack; but are mutable, so unlike "str" they can't be static;</div><div><p></p></div><div>automatic referencing in method calls (auto_borrow for self);</div><div><p></p></div><div>Rust auto_dereferences variables when:</div><div>, making method calls on a reference</div><div>, passing a ref as a function argument (because the type signature for functions are mandatory)</div><div>you have to deref vars when:</div><div>, assigning to them without type annotation</div><div>, using overloaded operators</div><div><p></p></div><div>if x doesn't implement foo() but implements Deref then x.foo() --&gt; x.deref().foo()</div><div><p></p></div><div><b>type system</b></div><div>types show us what we can do with the data (which operations are valid);</div><div><p></p></div><div>the class hierarchy design like in Java is problematic;</div><div>  <a href='http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html'>http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html</a></div><div>also the problem of covariance for generic types, has its root in this problem;</div><div>  <a href='https://en.wikipedia.org/wiki/Wildcard_(Java)'>https://en.wikipedia.org/wiki/Wildcard_(Java)</a></div><div>i think this is also the reason some prefer dynamic typing (another bad design) over static typing;</div><div>the right way is to use structs and traits (like in Rust and Go):</div><div>, structs are like final classes in Java, we use them to make object, but we can't inherit other classes from them;</div><div>, traits are like abstract classes in Java, we can inherit other classes from them, but we can't directly use them to make objects;</div><div>this way, all non_leaf classes will be abstract (traits), and all leaf classes will be final (structs);</div><div><p></p></div><div>tuples (heterogeneous, fixed size collection):</div><div>x = (1, "aaa")</div><div>named tuple: {i: 1, j: "aaa"}</div><div>access:</div><div>, destructuring</div><div>  let (a, b) = (1, "aaa")</div><div>, dot notation</div><div>  tuples: x.0 (literal number only)</div><div>  named tuples: x.i</div><div><p></p></div><div>arrays (homogeneous, fixed sized collection):</div><div>  indexing can be done at runtime because all elements have the same type;</div><div>vectors and hash tables (homogeneous, varying sized collection)</div><div><p></p></div><div>dot notation is used where we can destucture (tuples, structures);</div><div>double colon "::" is for namespacing;</div>
<h2>4, functional reactive programming</h2><div>imperative programming is done by procedurally changing stored values, it resembles the way CPU runs the instructions stored in memory;</div><div>imperative programming leads to unmaintainable code in large programs, and it makes writing parallel programs a cumbersome task;</div><div><p></p></div><div>functional reactive programming:</div><div>when the output channels of a function is empty and the input channels are full, the function consumes its inputs and fills its outputs with computed values;</div><div>initially all channels have default values, so feedbacks are possible;</div><div><p></p></div><div>functions just compute new data, they don't change anything outside of the function; but many computations need to mutate the data given to them, because the data is big and copying it would be inefficient;</div><div>one method as seen in languages like Haskell and Clojure is to use persistent data structures; in this method only the mutated part of data is computed and the rest of data is accessed through a reference to the original data; this may introduce some efficiency costs, but more importantly this method needs garbage collection;</div><div>another method is to use value semantics and copy_on_write, as in Swift; this method introduces some run_time cost because of reference counting; (it's actually a run_time solution)</div><div>the key to a real solution is move semantics (also known as uniqueness or linear types), as used in LinearML, Mercury and Rust; note that none of these languages need run_time garbage collection;</div><div><p></p></div><div>passing data across functions:</div><div>, copy (for small primitive data)</div><div>, borrow (immutable, lifetime is known at compile_time)</div><div>, counted reference (immutable, lifetime is unknown at compile_time)</div><div>, move (for linear type data, in_place mutability is possible)</div><div><p></p></div><div>, static data (like functions): no problem, share by reference</div><div>, dynamic data</div><div>  , small data: move it, or share by copying</div><div>  , big data: move (no sharing)</div><div>functional reactive programming allow us to program without the need to share big data;</div><div><p></p></div><div>keep related states in one place (to avoid copying big data);</div><div>a set of messages as input;</div><div>each kind of message changes one part of the state;</div><div><p></p></div><div>from "Henry G Baker, use_once variables and linear objects":</div><div>programming languages should have use_once variables in addition to the usual multiple_use variables; use_once variables are bound to linear (unshared, unaliased, or singly_referenced) objects; linear objects are cheap to access and manage, because they require no synchronization or tracing garbage collection; linear objects can elegantly and efficiently solve otherwise difficult problems of functional systems, eg in_place updating and the efficient initialization of functional objects;</div><div>a use_once variable must be dynamically referenced exactly once within its scope; unreferenced use_once variables must be explicitly killed, and multiply_referenced use_once variables must be explicitly copied; use_once variables are bound only to linear objects, which may reference other linear or non_linear objects; non_linear objects can reference other non_linear objects, but can reference a linear object only in a way that ensures mutual exclusion;</div><div>linear objects and use_once variables map elegantly into data_flow models of concurrent computation; and the graphical representations of data_flow models make an appealing visual linear programming language;</div><div>the acceptance by a function of a linear argument object places a great responsibility on the function; the function must either pass the linear object to another function as an argument, explicitly dispose of it, or return it as a return value;</div><div>a linear language is ideal for a dataflow architecture, which must explicitly duplicate/delete (linear) tokens;</div><div><p></p></div><div>move semantics + streams: the right approach to functional reactive programming</div><div><p></p></div><div>in software, there is a limited number of central processing units (unlike in hardware where there is distinct processing units); so we use an event_loop and thread pool to implement functional reactive programming;</div><div><a href='https://tokio.rs/docs/going-deeper-futures/futures-mechanics/#adapters'>https://tokio.rs/docs/going-deeper-futures/futures-mechanics/#adapters</a></div><div><a href='https://tokio.rs/docs/going-deeper-futures/synchronization/#channels'>https://tokio.rs/docs/going-deeper-futures/synchronization/#channels</a></div><div><a href='https://tokio.rs/docs/going-deeper-futures/futures-model/'>https://tokio.rs/docs/going-deeper-futures/futures-model/</a></div><div><a href='http://asquera.de/blog/2017-03-01/the-future-with-futures/'>http://asquera.de/blog/2017-03-01/the-future-with-futures/</a></div><div><a href='https://docs.rs/futures/0.1.17/futures/'>https://docs.rs/futures/0.1.17/futures/</a></div><div><a href='https://docs.rs/futures/0.1.17/futures/stream/index.html'>https://docs.rs/futures/0.1.17/futures/stream/index.html</a></div><div><a href='https://docs.rs/futures/0.1.17/futures/stream/trait.Stream.html'>https://docs.rs/futures/0.1.17/futures/stream/trait.Stream.html</a></div><div><a href='https://docs.rs/futures/0.1.17/futures/sync/mpsc/struct.Receiver.html'>https://docs.rs/futures/0.1.17/futures/sync/mpsc/struct.Receiver.html</a></div><div><a href='https://docs.rs/futures-cpupool/0.1.5/futures_cpupool/'>https://docs.rs/futures-cpupool/0.1.5/futures_cpupool/</a></div><div><a href='https://docs.rs/fibers/0.1.6/fibers/'>https://docs.rs/fibers/0.1.6/fibers/</a></div><div><a href='https://docs.rs/bus/1.3.1/bus/'>https://docs.rs/bus/1.3.1/bus/</a></div>
<h2>5, graphics</h2><div>software rendering gives us a lot more flexibility, since we are not any more limited by a hardware implementation with triangle only rasterization, isolated shader programs, and fixed size buffers;</div><div><p></p></div><div>font-rs</div><div><a href='https://github.com/google/font-rs'>https://github.com/google/font-rs</a></div><div><a href='https://docs.rs/rusterize/'>https://docs.rs/rusterize/</a></div><div><a href='https://docs.rs/softrender/'>https://docs.rs/softrender/</a></div><div><a href='https://crates.io/crates/line_drawing'>https://crates.io/crates/line_drawing</a></div><div><a href='https://www.siggraph.org/education/materials/HyperGraph/scanline/outprims/drawline.htm'>https://www.siggraph.org/education/materials/HyperGraph/scanline/outprims/drawline.htm</a></div><div><a href='https://en.wikipedia.org/wiki/Bresenham's_line_algorithm'>https://en.wikipedia.org/wiki/Bresenham's_line_algorithm</a></div><div><a href='https://en.wikipedia.org/wiki/Midpoint_circle_algorithm'>https://en.wikipedia.org/wiki/Midpoint_circle_algorithm</a></div><div><a href='https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm'>https://en.wikipedia.org/wiki/Xiaolin_Wu%27s_line_algorithm</a></div><div><a href='http://members.chello.at/~easyfilter/bresenham.html'>http://members.chello.at/~easyfilter/bresenham.html</a></div><div><a href='https://nothings.org/gamedev/rasterize/'>https://nothings.org/gamedev/rasterize/</a></div><div><a href='https://magcius.github.io/xplain/article/'>https://magcius.github.io/xplain/article/</a></div><div><p></p></div><div>graphical objects are made of primitives; primitives are defined using a set of</div><div>parameters; each primitive has a specific algorithm for rasterization;</div><div>2d primitives: point, line, curve, triangle, curved area;</div><div>3d objects made of flat surfaces will be broken up into triangles;</div><div>3d objects made of curved surfaces can be broken up into a number of primitive 3d surfaces which can be easily projected to 2d;</div><div><a href='https://en.wikipedia.org/wiki/Quadric'>https://en.wikipedia.org/wiki/Quadric</a></div><div>also interpolation is a good method for amorphous surfaces;</div><div><p></p></div><div>2d objects will be rasterized into pixels (a pixel is a coordinate plus a color value);</div><div>then these rasterized objects will be drawn in the framebuffer, in layers over each other (in an overlay on top of all 3d objects);</div><div>rasterizing 3d objects, produces an array of fragments; a fragment, besides color, contains a normal and a depth;</div><div>when creating the pixels of the framebuffer from the fragments, the normals are used for lighting, and the depths are used for z_buffer;</div><div><p></p></div><div><a href='https://en.wikipedia.org/wiki/Stencil_buffer'>https://en.wikipedia.org/wiki/Stencil_buffer</a></div><div><a href='https://www.scratchapixel.com'>https://www.scratchapixel.com</a></div><div><a href='https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF'>https://www.scratchapixel.com/lessons/3d-basic-rendering/phong-shader-BRDF</a></div><div><p></p></div><div>graphical objects are of 2 kinds:</div><div>, those which we know will remain unchanged the next time we want to draw to the framebuffer; these objects are first rasterized into memory, then we copy it into framebuffer;</div><div>, those which we know will be changed (scaled, rotated, moved in z direction) the next time we want to draw to the framebuffer (which happens a lot for animations with high frame rate); these objects will be drawn directly to the framebuffer;</div><div>(framebuffer uses double buffering and v_sync)</div><div>note that if an object just moves in x_y plane (without rotation), the cached rasterization is still useful; for 2d objects we simply add a constant to the position of all pixels; for 3d objects we may additionally want to recompute the lighting of pixels from fragments;</div><div><p></p></div><div>graphical objects:</div><div>, primitives</div><div>, material</div><div>, cached rasterization (can be none)</div><div><p></p></div><div>graphical objects can be put in a layout tree; transformations on objects will be applied in groups, based on the tree;</div><div>objects are moved to the tree; they can be accessed only internally; it means that, unlike in a scene_graph, pointers to objects in the tree are not accessible globally; so there are no free pointers, and no need for run_time memory management;</div>
<h2>URL</h2><div><a href='https://github.com/damoonsaghian/Comshell'>https://github.com/damoonsaghian/Comshell</a></div><div>this project is public domain;</div>
<h2>6, existing tools</h2><div>Rust + Streams + GTK</div><div><a href='http://gtk-rs.org/docs/gtk/'>http://gtk-rs.org/docs/gtk/</a></div><div><a href='https://github.com/gtk-rs/examples/tree/master/src/bin'>https://github.com/gtk-rs/examples/tree/master/src/bin</a></div><div><a href='http://gtk-rs.org/docs/sourceview/'>http://gtk-rs.org/docs/sourceview/</a></div><div><a href='https://wiki.gnome.org/Projects/GtkSourceView'>https://wiki.gnome.org/Projects/GtkSourceView</a></div><div><a href='https://github.com/gtk-rs/webkit2gtk-rs'>https://github.com/gtk-rs/webkit2gtk-rs</a></div><div><a href='https://github.com/antoyo/relm'>https://github.com/antoyo/relm</a></div><div><p></p></div><div>Arch Linux provides a shared_library distribution system, which is simple and effective, and is very close to the original build process;</div><div><p></p></div><div>boot to an existing Arch Linux (the live image, or an already installed Arch Linux with arch-install-scripts package installed) then:</div><div>; timedatectl set-ntp true</div><div>list disks using "fdisk -l"; then use "fdisk /dev/sdx" to create 3 partitions:</div><div>  , +1M BIOS boot (code 4)</div><div>  , +550G EFI System (code 1)</div><div>  , and the rest for Linux filesystem (code 20)</div><div>format the partitions:</div><div>  ; mkfs.fat -F32 /dev/sdx2; mkfs.btrfs /dev/sdx3</div><div>  BTRFS is used because journaling file systems can only protect metadata, at an acceptable performance; since they need to write all file system operations twice, once to the journal, and once to the file system;</div><div>  copy_on_write provides consistency for both data and metadata; also, it can offer integrity of data and metadata (using checksums), at an acceptable overhead;</div><div>  in addition, COW also supports the creation of cheap snapshots and clones (because it does not overwrite data in place); users can take fast online backups without the need to use any special software technique like LVM;</div><div>; mount /dev/sdx3 /mnt</div><div><p></p></div><div>; pacstrap /mnt pacman</div><div>; arch-chroot /mnt</div><div>install packages (to save bandwidth you can copy your already downloaded packages to "/mnt/var/cache/pacman/pkg"):</div><div>; pacman -S grub sed intel-ucode linux systemd-sysvcompat btrfs-progs nano man-db logrotate networkmanager pulseaudio-alsa sudo udisks2 ttf-hack ttf-droid numix-gtk-theme xorg-server xf86-video-{intel,nouveau,amdgpu} xorg-xinit gtk3 gtksourceview3 vte3 gst-plugins-{base,good,bad} gst-libav webkit2gtk rust rust-docs gcc</div><div><p></p></div><div>install bootloader:</div><div>; grub-install --target=i386-pc /dev/sdx</div><div>; mkdir /boot/efi; mount /dev/sdx2 /boot/efi</div><div>; grub-install --target=x86_64-efi --efi-directory=/boot/efi --removable</div><div>; grub-mkconfig -o /boot/grub/grub.cfg</div><div>; nano /boot/grub/grub.cfg</div><div>  set timeout = 0</div><div><p></p></div><div>create user:</div><div>; useradd -m -G wheel user1</div><div>; passwd -d user1</div><div>; EDITOR=nano visudo</div><div>  %wheel ALL=(ALL) ALL</div><div>; mkdir /etc/systemd/system/getty@tty1.service.d</div><div>; nano /etc/systemd/system/getty@tty1.service.d/override.conf</div><div>  [Service]</div><div>  ExecStart=</div><div>  ExecStart=-/usr/bin/agetty --autologin user1 --noclear %I $TERM</div><div><p></p></div><div>; systemctl enable NetworkManager.service</div><div>; systemctl enable systemd-timesyncd.service</div><div>; exit</div><div>; reboot</div><div><p></p></div><div>; mkdir -p ~/.config/gtk-3.0; nano ~/.config/gtk-3.0/settings.ini</div><div>  [Settings]</div><div>  gtk-theme-name = Numix</div><div>  gtk-font-name = Sans</div><div>; nano ~/.bash_profile</div><div>  export TZ="/usr/share/zoneinfo/&lt;your_location&gt;"</div><div>  startx</div><div>; cp /etc/X11/xinit/xinitrc ~/.xinitrc; nano ~/.xinitrc</div><div>  exec cargo run --release --manifest-path ~/projects/Comshell/Cargo.toml</div></body></html>