
<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<title>Comshell
</title>

<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro' rel='stylesheet'>
<style>
  body {
    padding: 1em;
    margin: 0;
    font-family: 'Source Code Pro', monospace;
    font-size: 1em;
    max-width: 50em;
    white-space: pre-wrap
  }
  div {
    margin-left: 1em;
    text-indent: -1em;
  }
</style>

</head>

<body>
<h1>Comshell
</h1>
<a href='https://github.com/damoonsaghian/Comshell
'>https://github.com/damoonsaghian/Comshell
</a>
<h2>1, command based user interface</h2><div>command based user interfaces (using keyboard, voice, gesture) are faster more convenient and more powerful than pointing based user interfaces (using mouse, touch, pen).</div><div>pointing interfaces can be useful only for very simple tasks. also for some special artistic applications pen input remains the only choice.</div><div><p></p></div><div><img src='keyboard.png' alt='keyboard.png'/></div><div>, two commas --&gt; .</div><div>, comma followed by ' --&gt; "</div><div>, comma followed by ( --&gt; [</div><div>, comma followed by add followed by comma --&gt; +</div><div>, comma followed by add followed by space --&gt; + followed by space</div><div>, comma followed by psi followed by space --&gt; ?</div><div>, two apostrophies followed by a --&gt; A</div><div><p></p></div><div>Vim'like key'bindings</div><div>modes (like normal mode and insert mode) must be visually distinctive.</div><div>pressing "esc" key always take you back to normal mode.</div><div>in normal mode we can:</div><div>, create a new project or chapter</div><div>, show projects or chapter, move between them (previous, next), and then press space to open or raise them, or directly go to them by entering their number</div><div>, move the cursor to the next or previous (or by entering the number directly to) words, lines (or table cells), paragraphs, pages</div><div>, start and end selection, then copy or cut</div><div>, paste</div><div>, undo, redo</div><div>, find</div><div>, enter insert mode</div><div><p></p></div><div>command based interactions are much simpler for a speech recognition engine to process, since it needs to match against a relatively small set of commands, unlike a general speech to text process.</div><div>a headset with near range microphone can be used, to exclude far away sound sources. also it is better to put battery and bluetooth of the headset in a separate unit, that can be put in the pocket. this makes the headset lighter and safer.</div><div>for those that neither can use all their fingers, nor can talk, gesture based interface can be implemented.</div><div><p></p></div><div>Comshell is a command based user interface, being developed using Rust ecosystem.</div>
<h2>2, graphics</h2><div>, retained mode graphics libraries (like GTK, or more advanced scene'graph based libraries, like Clutter, and most game engines) tend to extensively use class hierarchies, and run'time memory managment. so by using them we lose the real benefits of programming in Rust.</div><div>, immediate mode graphics libraries (like Piston2d-graphics, NanoVG, Nuklear, Raylib, ImGUI) are simpler to design and thus usually don't need those complexities. but they are implemented in such a way that every time there is a change, all graphical objects must be recreated, because graphical objects are not retained. this is obviously inefficient.</div><div><p></p></div><div>in retained mode we send all the geometry to the graphics card once, then, submit draw calls to render what is already there in v'r'a'm.</div><div><p></p></div><div>in immediate mode, the u'i is just a function of the current application state, thus the application is not responsible for explicitly managing the u'i state and keeping it synced with app. so it seems to be the simpler approach.</div><div>but in fact, retained mode graphics is the right approach. the reason for the complexities usually associated with it is because of the imperative programming.</div><div>interestingly imperative programming is also the root of complexities associated with life'times in Rust. in functional reactive programming, move semantic is actually a necessity, and there is no need to deal with life'times.</div><div><p></p></div><div>rust-sfml is special:</div><div>, we can create retained graphical objects, which can be rotated, scaled, moved, etc.</div><div>, but unlike sophisticated retained mode libs, there is no class hierarchies, and no ref counting.</div><div><p></p></div><div>maybe Vulkan is  more flexible than OpneGL, but then again why ever bother with a hardware a'p'i.</div><div><p></p></div><div>software rendering gives us a lot more flexibility, since we are not any more limited by a hardware implementation with fixed size buffers, and isolated shader programs.</div><div>font-rs <a href='https://github.com/google/font-rs'>https://github.com/google/font-rs</a></div><div><a href='https://docs.rs/softrender/'>https://docs.rs/softrender/</a></div><div><a href='https://docs.rs/rusterize/'>https://docs.rs/rusterize/</a></div><div><a href='https://crates.io/crates/rust-3d'>https://crates.io/crates/rust-3d</a></div><div><a href='https://crates.io/crates/mash'>https://crates.io/crates/mash</a></div><div><a href='https://crates.io/crates/line_drawing'>https://crates.io/crates/line_drawing</a></div><div><a href='https://crates.io/crates/cgmath'>https://crates.io/crates/cgmath</a></div><div><a href='https://crates.io/crates/plexus'>https://crates.io/crates/plexus</a></div><div><p></p></div><div>there are different types of graphical objects, defined with a set of parameters. each type has a specific algorithm for rasterization.</div><div>rasterized objects (3d rasterizations made of 3d positioned fragments) will be cached. so tranlating and rotating objects would not need re'rasterizing. they can even be used in pixelated zooming as the middle frames, to decrease the amount of rasterization for a smooth zooming.</div><div>more over, by caching individual rasterized objects, when there is a change in an object, there is no need to rasterize everything from the beginning.</div><div><p></p></div><div>graphical objects:</div><div>, parameters</div><div>, fragments</div><div>, are fragments synced with vertices and connectors</div><div><p></p></div><div>using the fragments, graphical objects are drawn a 2d texture in r'a'm. this texture will be copied directly to the output framebuffer (which uses double buffers and v'sync).</div><div><p></p></div><div>create graphical objects.</div><div>put them in a tree.</div><div>transformations on objects will be applied in groups, based on the tree.</div><div>current object index</div><div>note that unlike a scene'graph, pointers to objects which are held in the tree, are not accessable by the user. they are accessed only using tree indexing. so there are no free pointers, and no need for run'time memory management.</div><div><p></p></div><div>the data stream sent to the graphics function contains:</div><div>1, the new object to be added beside the currently selected object. (can be none)</div><div>2, the transformation which must be applied to this new object (in which case, the transformation can be none), or to the selected object (if there is no new object).</div><div>3, the index, or the relative motion of the index of currently selected object in the tree.</div><div><p></p></div><div>so here it is. we can finally implement an efficient functional reactive g'u'i.</div>
<h2>minimal system</h2><div>use Debian Linux to setup a minimal operating system.</div><div><p></p></div><div>use btrfs, because journaling file systems can only protect metadata at an acceptable performance, since they need to write all file system operations twice, once to the journal, and once to the file system.</div><div>copy'on'write provides consistency for both data and metadata.</div><div>also, it can offer integrity of data and metadata (using checksums), at an acceptable overhead.</div><div>in addition, c'o'w also supports the creation of cheap snapshots and clones (because it does not overwrite data in place). users can take fast online backups without the need to use any special software technique like l'v'm.</div><div><p></p></div><div>automatic login:</div><div>  systemctl edit getty@tty1</div><div>    [Service]</div><div>    ExecStart=</div><div>    ExecStart=-/usr/bin/agetty --autologin root --noclear %I $TERM</div><div>exit; reboot</div><div><p></p></div><div>go to Comshell/cargo dir and:</div><div>  cargo build --release</div><div>  sudo cp .cache/release/comshell /comshell/comshell</div><div>  cp -R ../.data /comshell/</div><div>add this line to "~/.profile":</div><div>  /comshell/comshell</div><div><p></p></div><div>Comshell looks for projects in "~/projects/" and "/projects/".</div><div>a shared project directory can be created like this:</div><div>  mkdir /projects; chmod a+w /projects</div>
<h2>useful libs</h2><div>text editing:</div><div><a href='https://github.com/jmacdonald/scribe'>https://github.com/jmacdonald/scribe</a></div><div><a href='https://github.com/mathall/rim'>https://github.com/mathall/rim</a></div><div><a href='https://github.com/gchp/iota'>https://github.com/gchp/iota</a></div><div><a href='https://github.com/zovt/tea'>https://github.com/zovt/tea</a></div><div><p></p></div><div>web:</div><div><a href='https://github.com/servo/rust-url/'>https://github.com/servo/rust-url/</a></div><div><a href='https://crates.io/crates/hyper'>https://crates.io/crates/hyper</a></div><div>  <a href='https://crates.io/crates/hyper-rustls'>https://crates.io/crates/hyper-rustls</a></div><div>  <a href='https://crates.io/crates/reqwest'>https://crates.io/crates/reqwest</a></div><div>  <a href='https://crates.io/crates/simplist'>https://crates.io/crates/simplist</a></div><div><a href='https://crates.io/crates/httpbin'>https://crates.io/crates/httpbin</a></div><div><a href='https://crates.io/crates/httpbis'>https://crates.io/crates/httpbis</a></div><div><a href='https://crates.io/crates/xmpp-proto'>https://crates.io/crates/xmpp-proto</a></div><div><a href='https://crates.io/crates/pijul'>https://crates.io/crates/pijul</a> (version control system)</div><div><a href='https://crates.io/crates/github-rs'>https://crates.io/crates/github-rs</a></div><div><p></p></div><div>media:</div><div><a href='https://github.com/pcwalton/rust-media'>https://github.com/pcwalton/rust-media</a></div><div><a href='https://github.com/tomaka/rodio'>https://github.com/tomaka/rodio</a></div><div><a href='https://github.com/tomaka/cpal'>https://github.com/tomaka/cpal</a></div><div><a href='https://crates.io/crates/lewton'>https://crates.io/crates/lewton</a></div><div><a href='https://crates.io/crates/camera_capture'>https://crates.io/crates/camera_capture</a></div><div><a href='https://crates.io/crates/mpv'>https://crates.io/crates/mpv</a></div><div><a href='https://trac.ffmpeg.org/wiki/HWAccelIntro'>https://trac.ffmpeg.org/wiki/HWAccelIntro</a></div></body></html>