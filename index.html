
<!DOCTYPE html>
<html>
<head>
<meta charset='utf-8'>
<title>Comshell
</title>

<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro' rel='stylesheet'>
<style>
  body {
    padding: 1em;
    margin: 0;
    font-family: 'Source Code Pro', monospace;
    font-size: 1em;
    max-width: 50em;
    white-space: pre-wrap
  }
  div {
    margin-left: 1em;
    text-indent: -1em;
  }
</style>

</head>

<body>
<h1>Comshell
</h1>
<a href='https://github.com/damoonsaghian/Comshell
'>https://github.com/damoonsaghian/Comshell
</a>
<h2>1, command based user interface</h2><div>command based user interfaces (using keyboard, voice, gesture) are faster more convenient and more powerful than pointing based user interfaces (using mouse, touch, pen).</div><div>pointing interfaces can be useful only for very simple tasks. also for some special artistic applications pen input remains the only choice.</div><div><p></p></div><div><img src='keyboard.png' alt='keyboard.png'/></div><div>, two commas --&gt; .</div><div>, comma followed by ' --&gt; "</div><div>, comma followed by ( --&gt; [</div><div>, comma followed by add followed by comma --&gt; +</div><div>, comma followed by add followed by space --&gt; + followed by space</div><div>, comma followed by psi followed by space --&gt; ?</div><div>, two apostrophies followed by a --&gt; A</div><div><p></p></div><div>Vim'like key'bindings</div><div>modes (like normal mode and insert mode) must be visually distinctive.</div><div>pressing "esc" key always take you back to normal mode.</div><div>in normal mode we can:</div><div>, create a new project or chapter</div><div>, show projects or chapter, move between them (previous, next), and then press space to open or raise them, or directly go to them by entering their number</div><div>, move the cursor to the next or previous (or by entering the number directly to) words, lines (or table cells), paragraphs, pages</div><div>, start and end selection, then copy or cut</div><div>, paste</div><div>, undo, redo</div><div>, find</div><div>, enter insert mode</div><div><p></p></div><div>command based interactions are much simpler for a speech recognition engine to process, since it needs to match against a relatively small set of commands, unlike a general speech to text process.</div><div>a headset with near range microphone can be used, to exclude far away sound sources. also it is better to put battery and bluetooth of the headset in a separate unit, that can be put in the pocket. this makes the headset lighter and safer.</div><div>for those that neither can use all their fingers, nor can talk, gesture based interface can be implemented.</div><div><p></p></div><div>Comshell is a command based user interface, being developed using Rust ecosystem.</div>
<h2>2, g'u'i</h2><div>retained'mode (scene'graph) graphics library</div><div><a href='https://www.enlightenment.org/program_guide/evas/ui_rendering_mode'>https://www.enlightenment.org/program_guide/evas/ui_rendering_mode</a></div><div><a href='https://docs.enlightenment.org/efl/current/evas_main.html'>https://docs.enlightenment.org/efl/current/evas_main.html</a></div><div><p></p></div><div>GTK is good for text, image, and layouts. it has good Rust bindings (even for Gstreamer and Webkit). but it doesn't provide a 3d scene'graph.</div><div>Qt has retained 2d/3d, but Rust bindings are terrible. and it seems that creating a good binding is impossible.</div><div>EFL has scene'graph based graphics from the ground up. but its image'based (as opposed to vector'based), maintenance is not very good, and there is no active Rust bindings.</div><div><p></p></div><div>Clutter seems to be a good choice. there is no actively maintained Rust bindings for Clutter. but it seems easy to create one:</div><div>  <a href='https://github.com/gtk-rs/gir/'>https://github.com/gtk-rs/gir/</a></div><div>the scene'graph in Clutter is made up of actors. inside an actor, we can draw anything, using (immediate'mode) Cogl a'p'i.</div><div><a href='https://developer.gnome.org/clutter-cookbook/stable/actors-non-rectangular.html'>https://developer.gnome.org/clutter-cookbook/stable/actors-non-rectangular.html</a></div><div><p></p></div><div>to install Clutter in Windows use MSYS2.</div><div>you must also add MSYS2 bin directory to the paths environment variable. e'g for 64 bit version:</div><div>  SET PATH=%PATH%;C:\msys64\mingw64\bin</div><div>  SETX PATH "%PATH%"</div><div><p></p></div><div><b>Cogle inside Clutter</b></div><div>once you have a custom actor, override the paint method with this:</div><div>static void scene_actor_paint (ClutterActor *actor) {</div><div>  CoglMatrix mvMatrix, pMatrix;</div><div>  </div><div>  cogl_get_modelview_matrix( &mvMatrix );</div><div>  cogl_get_projection_matrix( &pMatrix );</div><div>  </div><div>  cogl_set_modelview_matrix( &matrix );</div><div>  </div><div>  cogl_perspective( fov,</div><div>    (float)stage_width / (float)stage_height,</div><div>    zNear,</div><div>    zFar );</div><div>  </div><div>  // Let pilot know its position and attitude</div><div>  pilot_setPosition( telemetry.lat, telemetry.lon, telemetry.alt );</div><div>  pilot_setAttitude( telemetry.pitch, telemetry.roll, telemetry.yaw );</div><div>  </div><div>  // This rotates the world around the pilot...</div><div>  pilot_display();</div><div>  </div><div>  // show some objects</div><div>  yyyyyyyy_display();</div><div>  ......</div><div>  </div><div>  cogl_set_modelview_matrix( &mvMatrix );</div><div>  cogl_set_projection_matrix( &pMatrix );</div><div>}</div><div><p></p></div><div>and then in order to render some other object in this scene:</div><div>void yyyyyyyy_display() {</div><div>  cogl_push_source( material );</div><div><p></p></div><div>  cogl_push_matrix ();</div><div>  cogl_translate( home_e, home_n, home_d );</div><div>  cogl_rotate( home_hdg, 0.0, 0.0, 1.0 );</div><div>  cogl_rotate( home_elev, 1.0, 0.0, 0.0 );</div><div>  </div><div>  cogl_polygon( vertices, 12, FALSE );      </div><div>  cogl_pop_matrix ();</div><div><p></p></div><div>  cogl_pop_source();</div><div>}</div><div><p></p></div><div>so this is how you jump out of the clutter loop:</div><div>1, define a custom actor.</div><div>2, define some properties that modify how things are rendered and some other general behavior.</div><div>3, override the paint loop. save the matrices, define your own matrices, call your custom drawing code in 3d (has to be cogl) and then put the matrices back as you found them.</div>
<h2>3, useful libs</h2><div>text editing:</div><div><a href='https://github.com/jmacdonald/scribe'>https://github.com/jmacdonald/scribe</a></div><div><a href='https://github.com/mathall/rim'>https://github.com/mathall/rim</a></div><div><a href='https://github.com/gchp/iota'>https://github.com/gchp/iota</a></div><div><a href='https://github.com/zovt/tea'>https://github.com/zovt/tea</a></div><div><p></p></div><div>web:</div><div>CEF:</div><div>  <a href='https://en.wikipedia.org/wiki/Chromium_Embedded_Framework'>https://en.wikipedia.org/wiki/Chromium_Embedded_Framework</a></div><div>  <a href='https://github.com/cztomczak/cefcapi'>https://github.com/cztomczak/cefcapi</a></div><div>  <a href='https://github.com/kkartaltepe/rust-cef'>https://github.com/kkartaltepe/rust-cef</a></div><div>  <a href='https://github.com/dylanede/cef-rs'>https://github.com/dylanede/cef-rs</a></div><div><a href='https://github.com/servo/rust-url/'>https://github.com/servo/rust-url/</a></div><div><a href='https://crates.io/crates/hyper'>https://crates.io/crates/hyper</a></div><div>  <a href='https://crates.io/crates/hyper-rustls'>https://crates.io/crates/hyper-rustls</a></div><div>  <a href='https://crates.io/crates/reqwest'>https://crates.io/crates/reqwest</a></div><div>  <a href='https://crates.io/crates/simplist'>https://crates.io/crates/simplist</a></div><div><a href='https://crates.io/crates/httpbin'>https://crates.io/crates/httpbin</a></div><div><a href='https://crates.io/crates/httpbis'>https://crates.io/crates/httpbis</a></div><div><a href='https://crates.io/crates/xmpp-proto'>https://crates.io/crates/xmpp-proto</a></div><div><a href='https://crates.io/crates/pijul'>https://crates.io/crates/pijul</a> (version control system)</div><div><a href='https://crates.io/crates/github-rs'>https://crates.io/crates/github-rs</a></div><div><p></p></div><div>media:</div><div><a href='https://github.com/sdroege/gstreamer-rs'>https://github.com/sdroege/gstreamer-rs</a></div><div><a href='https://trac.ffmpeg.org/wiki/HWAccelIntro'>https://trac.ffmpeg.org/wiki/HWAccelIntro</a></div><div><a href='https://crates.io/crates/mpv'>https://crates.io/crates/mpv</a></div><div><a href='https://github.com/pcwalton/rust-media'>https://github.com/pcwalton/rust-media</a></div><div><a href='https://github.com/tomaka/rodio'>https://github.com/tomaka/rodio</a></div><div><a href='https://github.com/tomaka/cpal'>https://github.com/tomaka/cpal</a></div><div><a href='https://crates.io/crates/lewton'>https://crates.io/crates/lewton</a></div><div><a href='https://crates.io/crates/camera_capture'>https://crates.io/crates/camera_capture</a></div><div><p></p></div><div><a href='https://wiki.gnome.org/Projects/libchamplain'>https://wiki.gnome.org/Projects/libchamplain</a></div>
<h2>4, a minimal system</h2><div>Fedora Linux can be used to get a minimal operating system (without a windowing system).</div><div>use btrfs, because journaling file systems can only protect metadata at an acceptable performance, since they need to write all file system operations twice, once to the journal, and once to the file system</div><div>copy'on'write provides consistency for both data and metadata</div><div>also, it can offer integrity of data and metadata (using checksums), at an acceptable overhead.</div><div>in addition, c'o'w also supports the creation of cheap snapshots and clones (because it does not overwrite data in place). users can take fast online backups without the need to use any special software technique like l'v'm.</div><div><p></p></div><div>install Clutter devel libs.</div><div>install Rust:</div><div>  curl https://sh.rustup.rs -sSf | sh</div><div>go to Comshell/cargo dir and:</div><div>  cargo build --release</div><div>  sudo cp .cache/release/comshell ~/.comshell/comshell</div><div>  cp -R ../.data ~/.comshell/</div><div>add this line to "~/.bash_profile":</div><div>  exec ~/.comshell/comshell</div><div><p></p></div><div>projects for each user are kept in ~/.comshell/users/user1/projects</div><div>(these users doesn't have anything to do with unix users. but Comshells with single users can effectivily be considered equivalent to the current unix user)</div><div>a shared project dir (shared even between unix users) can be created like this:</div><div>  mkdir /projects; chmod a+w /projects</div></body></html>