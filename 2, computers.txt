computers are programmable systems.

in conventional digital circuits when the inputs change the outputs can have temporary incorrect values until they stabilize to correct values. so gates with memory, must be synchronized with a global clock signal. the period of clock signal is made long enough for the circuit to become stable.
this forces us to split long operations into several smaller ones which can be performed in successive clock cycles (a technique known as pipelining). otherwise the circuit would be slow and inefficient.
in addition the widely distributed clock signal takes a lot of power, and must run whether the circuit is receiving inputs or not.
the solution is to use rendezvous channels, in which sends and receives, block until the other side is ready.
initially all channels have default values (this is necessary to cope with feedbacks). then gates start to fetch their inputs from channels and compute their output values. and when their following gates are ready to receive it, they send it to the output channels. now the gate itself is ready to receive new values on its inputs.

cpu, memory, peripherals, this seems to be the only practical architecture for the hardware of computers. though universal memory technologies (like magneto'resistive random'access memory) if possible, could make things simpler.
cpu runs a sequence of simple computations called instructions (packages of 0 and 1), one by one.

programs usually do not run directly on a computer hardware, instead they run on a more sophisticated software machine (a virtual machine) called kernel.
Linux is an example. one thing that i don't like about it (and indeed other Unix based operating systems) though is that most things appear in the file system. i think the reason is to make it possible to do a lot of things using shell scripts instead of a proper programming language, and i think it's a bad idea.

compilers are special programs that obtain computer instructions from a program written in a language which is human readable and structured. this way the written program will be portable to different computer architectures.

= type system
types show us what we can do with the data (which operations are valid).

"https://julialang.org/"

data constructors:
A :: (Int, Str) -> A
enums:
X :: Int -> B
Y :: (Int, Int) -> B

function definition:
f = (x, y) -> "chain of function applications"
other than bindings defined externally, we can use bindings defined locally (using where keyword).

multiple bindings using pattern matching

interfaces:
f :: (Int, I) -> Int
g :: I -> Str
A :: (Int, Str) -> A
f :: (Int, A) -> Int
  = (x, A(y, z)) -> x + y
g :: A -> Str
  = A(x, y) -> concat[y, "asd"]

tuples (heterogeneous, fixed size module system):
x = (a, b)
to access internal values: x.1 (literal number only)
named elements: (i = a, j = b)
and for indexing: x.i
private fields are indicated by an underline: (_i = a, j = b)
polymorphic field names: (i::T1 = a, i::T2 = b)
in fact, modules are tuples too. since the elements of a module are all written at the first column (without indentation), we can safely omit parentheses and commas.

arrays (homogeneous, varying sized collection):
x = [a, b]
indexing: x:i
note that if "x" is an array of integers, type of "x:i" is not "Int", it's "Maybe Int".
hash table: ["a" => a, "b" => b]
for string type keys, an alternative form is: [a = a, b = b]
and for indexing: x:"a"
