, retained mode graphics libraries (like GTK, or more advanced scene'graph based libraries, like Clutter, and most game engines) tend to extensively use class hierarchies, and run'time memory managment. so by using them we lose the real benefits of programming in Rust.
, immediate mode graphics libraries (like Piston2d-graphics, NanoVG, Nuklear, Raylib, ImGUI) are simpler to design and thus usually don't need those complexities. but they are implemented in such a way that every time there is a change, all graphical objects must be recreated, because graphical objects are not retained. this is obviously inefficient.

in immediate mode, the u'i is just a function of the current application state, thus the application is not responsible for explicitly managing the u'i state and keeping it synced with app. so it seems to be the simpler approach.
but in fact, retained mode graphics is the right approach. the reason for the complexities usually associated with it is because of the imperative programming.
interestingly imperative programming is also the root of complexities associated with life'times in Rust. in functional reactive programming, move semantic is actually a necessity, and there is no need to deal with life'times.

rust-sfml is special:
, we can create retained graphical objects, which can be rotated, scaled, moved, etc.
, but unlike sophisticated retained mode libs, there is no class hierarchies, and no ref counting.
since SFML uses OpenGL, it inherits the limitations of a hardware a'p'i.

software rendering gives us a lot more flexibility, since we are not any more limited by a hardware implementation with fixed size buffers, triangle only rasterization, and isolated shader programs.
font-rs "https://github.com/google/font-rs"
"https://docs.rs/softrender/"
"https://docs.rs/rusterize/"
"https://crates.io/crates/rust-3d"
"https://crates.io/crates/mash"
"https://crates.io/crates/line_drawing"
"https://crates.io/crates/cgmath"
"https://crates.io/crates/plexus"

graphical objects are made of primitives. primitives are defined with a set of parameters. each primitive has a specific algorithm for rasterization.
rasterized objects will be cached, so when there is a change in an object, there is no need to re'rasterize other objects.

graphical objects:
, primitives
, fragments obtained from rasterization
, are fragments updated

rasterized graphical objects will be copied directly to the output framebuffer (which uses double buffers and v'sync).

graphical objects can be put in a layout tree. transformations on objects will be applied in groups, based on the tree.
current object index
note that unlike a scene'graph, pointers to objects in the tree, are not accessable by the user. they are accessed only using tree indexing. so there are no free pointers, and no need for run'time memory management.

the data stream sent to the graphics function contains:
1, the new object to be added beside the currently selected object. (can be none)
2, the transformation which must be applied to this new object (in which case, the transformation can be none), or to the selected object (if there is no new object).
3, the index, or the relative motion of the index of currently selected object in the tree.

so here it is. we can finally implement an efficient functional reactive g'u'i.
