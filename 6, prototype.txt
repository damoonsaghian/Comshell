we can use existing tools, to create a prototype of the command based UI discussed in the previous chapter.

Arch Linux provides a shared_library distribution system, which is simple and effective, and is very close to the original build process;

boot to an existing Arch Linux (the live image, or an already installed Arch Linux with arch-install-scripts package installed) then:
; timedatectl set-ntp true

list disks using "fdisk -l"; then use "fdisk /dev/sdx" to create 3 partitions (first enter "g" command to create a GPT partition table, then enter "n" to add a new partition, and change its type using "t" command; at the end enter "w" to write and exit):
  , +1M BIOS boot (partition type code: 4)
  , +550M EFI System (partition tye code: 1)
  , and the rest for Linux filesystem
format the partitions:
  ; mkfs.fat -F32 /dev/sdx2; mkfs.ext4 /dev/sdx3

; mount /dev/sdx3 /mnt
now to reuse previously downloaded packages on your system, and to prevent them from being downloaded again, you can copy them to "/mnt/var/cache/pacman/pkg";

; pacstrap /mnt pacman
; arch-chroot /mnt
; pacman -S grub sed intel-ucode linux systemd-sysvcompat logrotate networkmanager pulseaudio-alsa udisks2 sudo nano man-db unzip rust rust-docs gcc xorg-server xf86-video-{intel,nouveau,amdgpu} xorg-xinit i3-wm i3status xdotool deepin-gtk-theme ttf-hack emacs ttf-droid chromium mpv

monospace fonts: wide characters are forced to squeeze, narrow characters are forced to stretch, uppercase letters look skinny next to lowercase, and bold characters donâ€™t have enough room;
proportional font for code: generous spacing, large punctuation, and easily distinguishable characters, while allowing each character to take up the space that it needs;
"http://input.fontbureau.com/info/"
two spaces -> elastic blocks
"http://nickgravgaard.com/elastic-tabstops/"

install bootloader:
; grub-install --target=i386-pc /dev/sdx
; mkdir /boot/efi; mount /dev/sdx2 /boot/efi
; grub-install --target=x86_64-efi --efi-directory=/boot/efi --removable
; grub-mkconfig -o /boot/grub/grub.cfg
; nano /boot/grub/grub.cfg
  set timeout = 0

create user:
; useradd -m -G wheel user1
; passwd -d user1
; EDITOR=nano visudo
  %wheel ALL=(ALL) ALL

; mkdir /etc/systemd/system/getty@tty1.service.d
; nano /etc/systemd/system/getty@tty1.service.d/override.conf
  [Service]
  ExecStart=
  ExecStart=-/usr/bin/agetty --autologin user1 --noclear %I $TERM

; systemctl enable NetworkManager.service
; systemctl enable systemd-timesyncd.service
; exit
; reboot

; mkdir -p ~/.config/gtk-3.0; emacs ~/.config/gtk-3.0/settings.ini
  [Settings]
  gtk-theme-name = deepin
  gtk-font-name = Sans

; nano ~/.bash_profile
  export TZ="/usr/share/zoneinfo/<your_location>"
  startx
; nano ~/.xinitrc
  exec i3

; mkdir -p ~/.config/i3
; cp i3.conf ~/.config/i3/config
; mkdir -p ~/.config/i3status
; cp i3status.conf ~/.config/i3status/config

; cp init.el ~/.emacs.d/init.el
ELisp is terrible as a programming language, but it's pretty good as a command interface (ie as a shell, like Bash).
