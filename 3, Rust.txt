Rust makes bad programming hard, and good programming fun.
Rust does not hide complexity, in fact it bolds it, so we can see it and avoid it.

evolution of C language:
, wrong approach:
  classes (C++)
  garbage collection:
    , classes (Java, C#, ...)
    , immutable data (Haskell)
, right approach: traits, move semantics (Rust)

shared mutability is the root of many complexities, especially in concurrent environments.
all references in Rust must either be unique or immutable.

any resource have exactly one owner which takes care of its resource deallocation.
"http://blog.skylight.io/rust-means-never-having-to-close-a-socket/"
owners can share their data by lending them to references. references must have a lifetime less than the owner.

owner can:
, control resource deallocation
, lend the resource:
  , immutably (multiple refs)
  , mutably (only on ref)
, hand over ownership (move)
owner can't:
, during borrow:
  , mutate the resource
  , mutably lend the resource
, during mutable borrow:
  , access the resource
  , lend the resource

reference can:
, access borrowed resource
, share (copy) an immutable borrow
mutable reference can:
, access and mutate resource
, hand over (move) the mutable borrow (mutable ref is moved by default)

scenarios that involve multiple refs or returning refs often require explicit lifetimes. so don't return refs, instead use mutable refs in inputs.
structs and enums containing refs must have explicit lifetimes (impl of these must use lifetimes too). so don't use them.


Rust have separate types for static and dynamic values. (str/String, fn/Fn)
functions can only access static environment. closures don't have this limitation. so when using them we might be more careful.
static data can be defined using only other static data.

arrays have a fixed size, so they can be implemented on stack. but are mutable, so unlike "str" they can't be static.

automatic referencing in method calls (auto_borrow for self)

Rust auto_dereferences variables when:
, making method calls on a reference
, passing a ref as a function arg (because the type sig for functions are mandatory)
you have to deref vars when:
, assigning to them without type annotation
, using overloaded operators

if x doesn't implement foo() but implements Deref then x.foo() --> x.deref().foo()

= type system
types show us what we can do with the data (which operations are valid).

the class hierarchy design like in Java is problematic.
  "http://ptgmedia.pearsoncmg.com/images/020163371x/items/item33.html"
also the problem of covariance for generic types, has its root in this problem.
  "https://en.wikipedia.org/wiki/Wildcard_(Java)"
i think this is also the reason some prefer dynamic typing (another bad design) over static typing.
the right way is to use structs and traits (like in Rust and Go):
, structs are like final classes in Java, we use them to make object, but we can't inherit other classes from them.
, traits are like abstract classes in Java, we can inherit other classes from them, but we can't directly use them to make objects.
this way, all non_leaf classes will be abstract (traits), and all leaf classes will be final (structs).

tuples (heterogeneous, fixed size collection):
x = (1, "aaa")
named tuple: {i: 1, j: "aaa"}
access:
, destructuring
  let (a, b) = (1, "aaa")
, dot notation
  tuples: x.0 (literal number only)
  named tuples: x.i

arrays (homogeneous, fixed sized collection):
  indexing can be done at runtime because all elements have the same type.
vectors and hash tables (homogeneous, varying sized collection)

dot notation is used where we can destucture (tuples, structures).
double colon "::" is for namespacing.
