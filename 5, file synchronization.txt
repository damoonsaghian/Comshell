the problem of shared mutable data is so pervasive in the computing world;
we can also see it in file synchronization tools like Git:
, there can be conflicts when pushing or pulling, which needs to be resolved manually;
, to allow shared mutability we have to keep the whole history in the repository;

solution:
only the owner of the repository can mutate it;
others have to send messages:
, in the form of to_dos defined by the owner;
, corrections
any one can apply corrections and to_dos locally, and test them,
  but they can't mutate the repository, only the owner can;

corrections and to_dos can created by editing a file using a special syntax;
when the user wants to send them, for any applied correction/to_do
  a file will be created in the public folder (if there is none),
  then the public folder will be synced;

SFTP:
, create a user with a temporary password;
, login, then disable multi login;
, reset ssh;
, login;
, make a homepage;
, put the fingerprint in "ssh_fingerprint.txt";
, change password;
, logout
, each time before login download the ssh key fingerprint, and append it to "~/.ssh/known_hosts";

to always have a consistent instance of files we use snapshots;

upload to remote:
, create a snapshot on the local machine;
, for each local file (except the public directory) calculate its hash, rename it to its hash;
, put the hash and path in the "index" file;
, sync using lftp;
, delete the local snapshot;

download from remote:
, create a snapshot on the local machine;
, for each file (except the public directory) calculate its hash, rename it to its hash;
, sync using lftp;
, rename the files to the original path, based on the "index" file;
, move the snapshot to the destination;
, if the downloaded files are inconsistent (according to the "index" file) try again;

files in ".cache" directory will no be synced;
so build directories must be put inside ".cache"; eg for Rust:
; nano ~/.cargo/config
  [build]
  target-dir = ".cache/cargo"
